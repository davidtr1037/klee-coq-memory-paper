\section{Introduction}

% Context

% TODO: mention loom / velvet / ...
% TODO: verified tool / certified tool
% TODO: add more citations for verification?
% TODO: define program safety
% TODO: which is the case in other analysis tools as well
Symbolic execution (\SE) is a program analysis technique with applications in many areas,
including test generation, bug finding, and verification~\cite{CadarSen13,klee,exe,spf,bugredux,se-java-2004,se-numerical-2006,syminfer}.
Although \SE has been used for verification tasks,
one cannot trust unverified \SE tools to infer that a program is indeed safe,
as was recently demonstrated in~\cite{klee-rocq}.
Obtaining a \SE tool that is both practical and verified is hard.
On the one hand,
verifying existing implementations requires a huge effort,
as they typically consist of large codebases with complex third-party dependencies.
One the other hand,
verified implementations extracted from proof assistants~\cite{fse23wise,icfp22:keuchel} were applied only for simple program languages,
and they lack advanced features such as: search heuristics, constraint solving optimizations, and other performance optimizations.
Proof logging is an alternative approach,
inspired by \emph{translation validation}~\cite{samet,pnueli1998translation} and not aiming for a verified implementation,
that generates during the analysis a safety proof that is specific to the analyzed program.

% Gap

% TODO: extending the theory for the extended semantics is also a gap
Proof logging has been recently applied in the context of P4~\cite{lundberg2024proof} and a subset of \llvm with integers~\cite{klee-rocq},
however, it has not yet been demonstrated on memory-manipulating programs.
Memory modeling is one of the most complex components in \SE tools,
%as well as in program analysis in general.
and applying proof logging in this context is a challenge as well.
For example, to extend the approach in~\cite{klee-rocq} for memory operations,
one needs to formalize the memory model of \llvm and extend the \SE engine to generate safety proofs accordingly.
Formalizing the memory model of \llvm is complex,
due to the detailed specifications related to various definitions such as:
data layout, address spaces, allocated objects, pointers, and semantics of memory-related instructions.
In addition, \SE tools use various memory optimizations, which complicates the proof generation process.
For example, \klee~\cite{klee} uses multiple representations for memory objects, applies SMT encoding optimizations, \etc

% The latest realistic implementation of symex (CPP26) supports only a limited subset.
% Challenges in symbolic memory model and formal reasoning.
% Example (running)?
% Convey the difficulties/challenges in extending to memory support.
% (dual representation full/opt)
% (data layout, memory objects; many special cases in spec)

% Innovation
%We leverage results from previous work, building on it, integrating
%with a new model for representing ...
%Mechanized symbolic memory model and its symbolic operational semantics.
%Address challenges arising from poison in gep via marking as error states (for ns), instrumenting KLEE with additional checks.
%Pointer resolution -- interface lemmas (for efficiency); mention nondet symbolic semantics of "resolve".
%The theory is a bit more abstract relative to the optimized implementation, and the inteface lemmas help adjust.

% TODO:
% turend out to be hard ...
% significant gap compared to a subset of integers
% memory modeling is typically the most complex/subtle component in program analysis tools (not only SE)
% not incremental...
% extending the formalization required a significant manual proof effort (+20k lines)
% compare to compcert?
% challenge: handle the gap between formal semantics and an optimized implementation (dual repr, ...)
% solution: interface lemmas / additional theory

% theoretical foundation
In this work,
we apply proof logging to memory-manipulating \llvm programs,
resulting in the first tool that can generate machined-checked safety proofs for this subset of \llvm.
%we extend the proof logging approach in~\cite{klee-rocq} to support memory operations.
First, we extend the concrete and symbolic semantics to support memory-related instructions.
Then, we extend the theoretical foundation which allows to prove program safety based on properties of execution trees.
Lastly, we extend \klee to generate safety proofs based on our formalization.
To address the gap between the formalized symbolic semantics and the heavily-optimized behavior in \klee,
we develop an additional theory consisting of \emph{interface lemmas} that help to interact with various parts of our formalization.

% TODO: mechanized concrete semantics? better modeling of GEP, etc.
% TODO: theory for program safety based on execution trees
% TODO: implemented ...
\begin{paragraph}{\textbf{Main Contributions:}}
\begin{itemize}
\item A formalization in \coq consisting of a concrete and symbolic semantics for a subset of \llvm with memory
      and a supporting theory for constructing safety proofs.
\item An extension of \klee that generates safety proofs based on our formalization.
\item We evaluated our approach on APIs from real-world benchmarks, and found several issues in \klee related to memory modeling.
\end{itemize}
\end{paragraph}
