\section{Introduction}
...

% Context
Trusting symbolic execution implementations.
Remind why a fully verified implementation is too hard to achieve.
Within that field, approach of proof logging.
Mention recent proof logging efforts and tools.

% Gap
The latest realistic implementation of symex (CPP26) supports only
a limited subset.
Challenges in symbolic memory model and formal reasoning.
Example (running)?
Convey the difficulties/challenges in extending to memory support.
(dual representation full/opt)
(data layout, memory objects; many special cases in spec)
% TODO mention Loom -- automatic proofs, but not for a real language (Velvet).

Mention some discrepancies in the impl of KLEE (pending PR)

% Innovation
We leverage results from previous work, building on it, integrating
with a new model for representing ...
Mechanized symbolic memory model and its symbolic operational semantics.
Address challenges arising from poison in gep via marking as error states (for ns), instrumenting KLEE with additional checks.
Pointer resolution -- interface lemmas (for efficiency); mention nondet symbolic semantics of "resolve". The theory is a bit more abstract relative to the optimized implementation, and the inteface lemmas help adjust.

% TODO:
% turend out to be hard ...
% significant gap compared to a subset of integers
% memory modeling is typically the most complex/subtle component in program analysis tools (not only SE)
% not incremental...
% extending the formalization required a significant manual proof effort (+20k lines)
% compare to compcert?

\begin{paragraph}{Our contributions.}
% mechanized concrete semantics?
% mechanized symbolic semantics
% extension of KLEE that generates safety proofs using interface lemmas
% interface lemmas for an efficient interaction between
% evaluation on real-world APIs with memory manipulations

\end{paragraph}
