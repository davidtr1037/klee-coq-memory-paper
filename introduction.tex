\section{Introduction}

% Context

% TODO: mention loom / velvet / ...
% TODO: verified tool / certified tool
% TODO: add more citations for verification?
% TODO: define program safety
% TODO: which is the case in other analysis tools as well
Symbolic execution (\SE) is a program analysis technique with applications in many areas,
including test generation, bug finding, and verification~\cite{CadarSen13,klee,exe,spf,bugredux,se-java-2004,se-numerical-2006,syminfer}.
Although \SE is used for verification,
one cannot trust unverified \SE tools to conclude that a program is safe,
as was recently demonstrated in~\cite{klee-rocq}.
Obtaining a verified implementation of a \SE tool is challenging.
On the one hand,
verifying existing implementations is hard,
as they typically consist of large codebases with complex third-party dependencies.
One the other hand,
verified implementations extracted from proof assistants~\cite{fse23wise,icfp22:keuchel} were applied only for simple program languages,
and they lack advanced features such as: search heuristics, constraint solving optimizations, and other performance optimizations.
An alternative approach, based on \emph{translation validation}~\cite{samet,pnueli1998translation} and not aiming for a verified implementation,
performs \emph{proof logging} during the analysis to generate a safety proof that is specific to the analyzed program.
% TODO: both don't support memory?
This approach was demonstrated, for example, for P4~\cite{lundberg2024proof} and a subset of \llvm with integers~\cite{klee-rocq}.

% Gap

% TODO: LLVM provides some freedom for memory modeling
% TODO: avoid dup: challenging / ...
Memory modeling is one of the most complex components in \SE tools,
as well as in program analysis in general.
To extend the approach in~\cite{klee-rocq} for memory operations,
one needs first to formalize the memory model of \llvm and then to extend the \SE engine to generate safety proofs accordingly.
Formalizing the memory model of \llvm is challenging,
due to the complex specifications related to various definitions such as: data layout, address spaces, allocated objects, pointers, and semantics of memory-related instructions.
In addition, \SE tools use various memory optimizations, which complicates the proof generation process.
For example, \klee~\cite{klee} uses multiple representations for memory objects, uses SMT encoding optimizations, \etc
Therefore, extending the proof-logging approach for \llvm programs with memory is challenging.

% The latest realistic implementation of symex (CPP26) supports only a limited subset.
% Challenges in symbolic memory model and formal reasoning.
% Example (running)?
% Convey the difficulties/challenges in extending to memory support.
% (dual representation full/opt)
% (data layout, memory objects; many special cases in spec)

% TODO: Mention some discrepancies in the impl of KLEE (pending PR)

% Innovation
We leverage results from previous work, building on it, integrating
with a new model for representing ...
Mechanized symbolic memory model and its symbolic operational semantics.
Address challenges arising from poison in gep via marking as error states (for ns), instrumenting KLEE with additional checks.
Pointer resolution -- interface lemmas (for efficiency); mention nondet symbolic semantics of "resolve". The theory is a bit more abstract relative to the optimized implementation, and the inteface lemmas help adjust.

% TODO:
% turend out to be hard ...
% significant gap compared to a subset of integers
% memory modeling is typically the most complex/subtle component in program analysis tools (not only SE)
% not incremental...
% extending the formalization required a significant manual proof effort (+20k lines)
% compare to compcert?
% challenge: handle the gap between formal semantics and an optimized implementation (dual repr, ...)
% solution: interface lemmas / additional theory

\begin{paragraph}{Our contributions.}
% mechanized concrete semantics?
% mechanized symbolic semantics
% extension of KLEE that generates safety proofs using interface lemmas
% interface lemmas for an efficient interaction between
% evaluation on real-world APIs with memory manipulations
\end{paragraph}
