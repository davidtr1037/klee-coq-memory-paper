\section{Implementation}
\label{sec:implementation}

% TODO: we added a new allocator to be aligned with...

Our implementation consists of two main components:
A formalization in \coq (9.0.1) and an extension of the \SE engine.
Our formalization is based on~\cite{klee-rocq}, and it includes the definition of the semantics and the theory discussed before (\Cref{sec:background,sec:core}).
Our formalization consists of roughly 40K lines of code, excluding third-party dependencis,
while the formalization from~\cite{klee-rocq} consists of 18K lines of code.
This highlights the substantial manual proof effort required to model memory.
Our proof generation approach (\Cref{sec:proof-generation}) is implemented on top of \klee~\cite{klee},
a \emph{state-of-the-art} \SE engine operating on \llvm IR~\cite{llvm}.
Some of the SMT transformations used in \klee are currently not supported by our implementation,
but we plan to support them in future versions.
Although the $\tgep$ instruction may have attributes (\opcode{nuw}, \opcode{nusw}, and \opcode{inbounds}),
our implementation currently supports only \opcode{nuw}.
We found several implementation issues in \klee that relate to memory modeling, which we discuss next.\footnote{
These issues were confirmed by the maintainers of KLEE.
The link is omitted due to double-blind reviewing.
}

\paragraph{\textbf{\textit{Inconsistent modeling of the index type.}}}
On one side,
\klee uses SMT arrays of sort $\arraysort{\smtsort{32}}{\smtsort{8}}$ to represent the contents of memory objects,
which suggests that the modeled index type is $\bvsort{32}$.
On the other side,
\klee computes the offsets in the interpretation of $\tgep$ using SMT expressions of sort $\smtsort{64}$,
which suggests that the modeled index type is $\bvsort{64}$.

\paragraph{\textbf{\textit{Memory Allocation.}}}
According to the \llvm semantics,
if the allocation size exceeds the largest \emph{signed integer} representable by the index type,
then the result is undefined behavior.
However, \klee currently does not check this condition.
Moreover, \klee silently truncates the allocation size to the \code{uint32\_t} type, without reporting any error to the user, which may lead to unexpected behavior.
For example, if we allocate an object of size $2^{32} + 10$,
then the allocation size is internally casted to $10$,
and if later we access that object at offset $10$, then we will get an out-of-bounds error, which is a false positive.

\paragraph{\textbf{\textit{Incorrect Interpretation of \textup{$\tgep$}.}}}
We found that the interpretation of $\tgep$ in \klee is not fully compliant with the \llvm reference,
as it does not account for overflows in the offset computation.
To fix this, we modified the interpretation of $\tgep$ as follows:
First, we modified the offset computation to conform to the index type $\bvsort{32}$,
ensuring consistency with the index sort $\smtsort{32}$ used in the SMT arrays.
Second, if the \code{nuw} attribute is enabled, we report an error when an overflow occurs.

%The lack of overflow checks has some additional consequences,
%as can be demonstrated by~\Cref{figure:klee-issue}.
%After executing the $\tgep$ instruction at~\cref{line:issue-llvm-gep}, the value of \code{p2} is $a + 4294967296$,
%assuming that the value of \code{p1} is $a$.
%Since \klee ignores the overflow in this case, it continues to the next instruction at~\cref{line:issue-llvm-store}.
%When \klee accesses a memory object (\ie $\tload$ and $\tstore$),
%the SMT expression of the offset is always truncated to an SMT expression of sort $\smtsort{32}$.
%So in this case,
%the SMT expression $4294967296$ (of sort $\smtsort{64}$) is truncated to the SMT expression $0$ (of sort $\smtsort{32}$).
%Therefore, this $\tstore$ instruction actually updates the first byte of the memory object allocated at~\cref{line:issue-llvm-malloc}.
%We note that this behavior occurs in \klee without reporting any errors to the user.

%\begin{figure}[t]
%\begin{minipage}[t]{0.44\columnwidth}
%\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=c,mathescape=true,breaklines=false]{code/alloc.simple.c}
%\end{minipage}
%\begin{minipage}[t]{0.52\columnwidth}
%\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=c,mathescape=true,breaklines=false]{code/alloc.simple.ll}
%\end{minipage}
%\caption{A simple C program and its translation to \llvm IR.}
%\label{figure:klee-issue}
%\end{figure}

%% TODO: fix...
%\begin{algorithm}[t]
%\caption{The algorithm for handling $\tgep$ in \klee.}
%\label{alg:gep-klee}
%\begin{algorithmic}[1]
%
%\Function{compute-offset}{$\tau, o, \overline{j}$}
%    \If {$|\overline{j}| = 0$}
%        \State \Return $o$
%    \EndIf
%    \State $\overline{j} \gets j_1 :: \overline{j'}$
%    \If {$\tau = \arraytype{\tau'}{n}$}
%        \State $o \gets \bvadd_{64}(o, \bvmul_{64}(\bvsext_{64}(j_1), \bvconst{64}{|\tau'|}))$ \label{line:array-index}
%        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
%    \EndIf
%    \If {$\tau = \structtype{\tau}{n}$}
%        \State ...
%    \EndIf
%    \State ...
%\EndFunction
%
%\Function{compute-pointer}{$\tau, p, j_0, \overline{j}$}
%    \State $o \gets \bvmul_{64}(\bvsext_{64}(j_0), \bvconst{64}{|\tau|})$ \label{line:first-index}
%    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
%    \State \Return $\bvadd_{64}(p, r)$
%\EndFunction
%
%\end{algorithmic}
%\end{algorithm}
