\section{Implementation}
\label{sec:implementation}

% TODO: prototype?
% TODO: we fixed the issues in our version
% TODO: we added a new allocator to be aligned with...

Our prototype implementation consists of two components:
A formalization of the concrete and symbolic semantics (\Cref{sec:concrete-semantics,sec:symbolic-semantics}) and an extension of the \SE engine.
Our formalization is manually written in \coq (8.19.1) and consists of roughly TBD lines of code, excluding third-party dependencies.
Our proof-generation approach (\Cref{sec:proof-generation}) is implemented on top of \klee~\cite{klee},
a \emph{state-of-the-art} \SE engine that operates on \llvm bitcode~\cite{llvm}.
Some of the SMT transformations used in \klee are currently not supported by our prototype,
but we plan to implement them in future versions.
During the implementation of our prototype,
we found several implementation issues in \klee that relate to memory modeling.
We now give a detailed overview of these issues.

\subsection{Implementation Issues in \klee}
% TODO: mention that different parts assume different index types
To represent the contents of a memory object, \klee uses an SMT array of sort:
\[ \smtsort{32} \rightarrow \smtsort{8} \]
Based on this, we conclude that the index type is assumed to be \bvsort{32}.

\subsubsection{Allocation}
According to the \llvm semantics,
if the allocation size exceeds the largest \emph{signed integer} that fits into the index type,
then the result is undefined behavior.
However, \klee currently does not check this condition.
In fact, \klee silently truncates the allocation size to the \code{uint32\_t} type, without reporting any error to the user.
To illustrate this behavior, consider the code snippet from~\Cref{figure:klee-issue}.
When executing~\cref{line:issue-malloc},
the allocation size (\code{UINT32\_MAX + 1 + 10}) is internally casted to the \code{uint32\_t} type,
so the actual allocation size is 10.

\begin{figure}[t]
\begin{minipage}[t]{0.44\columnwidth}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=c,mathescape=true,breaklines=false]{code/alloc.c.simpl}
\end{minipage}
\begin{minipage}[t]{0.52\columnwidth}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=c,mathescape=true,breaklines=false]{code/alloc.ll.simpl}
\end{minipage}
\caption{A simple C program and its translation to \llvm IR.}
\label{figure:klee-issue}
\end{figure}

\subsubsection{GEP}
The algorithm used in \klee to handle the $\tgep$ instruction is given in~\Cref{alg:gep-klee}.
As can be seen,
the offset computed at each iteration is converted to an expression of sort $\smtsort{64}$,
while the index type is assumed to be \bvsort{32}.
%Even if we assume that the index type is \bvsort{64},
In addition,
the algorithm does not account for overflows when computing the resulting pointer.

% TODO: mention that the type of (n + 1) is i64?
The lack of overflow checks has some additional consequences,
as can be demonstrated by~\Cref{figure:klee-issue}.
After executing the $\tgep$ instruction at~\cref{line:issue-llvm-gep}, the value of \code{p2} is $a + 4294967296$,
assuming that the value of \code{p1} is $a$.
Since \klee ignores the overflow in this case, it continues to the next instruction at~\cref{line:issue-llvm-store}.
When \klee accesses a memory object (\ie $\tload$ and $\tstore$),
the SMT expression of the offset is always truncated to an SMT expression of sort $\smtsort{32}$.
So in this case,
the SMT expression $4294967296$ (of sort $\smtsort{64}$) is truncated to the SMT expression $0$ (of sort $\smtsort{32}$).
Therefore, this $\tstore$ instruction actually updates the first byte of the memory object allocated at~\cref{line:issue-llvm-malloc}.
We note that this behavior occurs in \klee without reporting any errors to the user.

% TODO: fix...
\begin{algorithm}[t]
\caption{The algorithm for handling $\tgep$ in \klee.}
\label{alg:gep-klee}
\begin{algorithmic}[1]

\Function{compute-pointer}{$p : \smtsort{64}$}
    \For {$i : ...$}
        \State $p \gets \bvadd \ b \ (\bvsext \ i \ \bvsort{64})$
    \EndFor
    \Return $p$
\EndFunction

\end{algorithmic}
\end{algorithm}
