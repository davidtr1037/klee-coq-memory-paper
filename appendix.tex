\section{Module Assumptions}
\label{appendix:module-assumptions}
If the indexed type of a given index in a $\tgep$ instruction is a struct type,
then that index must be a constant and lie within the range of $\bvsort{64}$.

\section{Concrete Semantics}
\label{appendix:concrete-semantics}
% TODO: handle the struct case
The semantics of the $\tgep$ instruction is given in~\Cref{alg:gep}.

\begin{algorithm}[t]
\caption{The semantics of $\tgep$ (without attributes).}
\label{alg:gep}
\begin{algorithmic}[1]

\Function{compute-offset}{$\tau, o, \overline{j}$}
    \If {$|\overline{j}| = 0$}
        \State \Return $o$
    \EndIf
    \State $\overline{j} \gets j_1 :: \overline{j'}$
    \If {$\tau = \arraytype{\tau'}{n}$}
        \State $o \gets o + \convert_{\indextype}(j_1) \cdot \valoftype{|\tau'|}{\indextype}$ \label{line:array-index}
        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
    \EndIf
    \If {$\tau = \structtype{\tau}{n}$}
        \State ...
    \EndIf
\EndFunction

\Function{eval\_gep}{$\tau, p, \overline{j}$}
    \If {$\tpoison \in \overline{j}$}
        \State \Return $\tpoison$
    \EndIf
    \If {$\tundef \in \overline{j}$}
        \State \Return $\tundef$
    \EndIf
    \State $j_0 :: \overline{j} \gets \overline{j}$
    \State $o \gets \convert_{\indextype}(j_0) \cdot \valoftype{|\tau|}{\indextype}$ \label{line:first-index}
    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
    \State \Return $p + \zeroext_{\pointertype}(r)$
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Symbolic Semantics}
\label{appendix:symbolic-semantics}
% TODO: handle the struct case
The symbolic semantics of the $\tgep$ instruction is given in~\Cref{alg:symbolic-gep}.
Here, you may assume that $\bvsext_{32}(t)$ is defined as follows:
If the width of $t$ is less than 32 it performs sign extension,
and if the width of $t$ is greater than 32 it performs truncation.

\begin{algorithm}[t]
\caption{The symbolic semantics of $\tgep$ (without attributes).}
\label{alg:symbolic-gep}
\begin{algorithmic}[1]

\Function{compute-offset}{$\tau, o, \overline{j}$}
    \If {$|\overline{j}| = 0$}
        \State \Return $o$
    \EndIf
    \State $\overline{j} \gets j_1 :: \overline{j'}$
    \If {$\tau = \arraytype{\tau'}{n}$}
        \State $o \gets \bvadd{\bvsort{32}}{o}{\bvmul{\bvsort{32}}{\bvsext_{32}(j_1)}{\bvconst{32}{|\tau'|}}}$ \label{line:array-index}
        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
    \EndIf
    \If {$\tau = \structtype{\tau}{n}$}
        \State ...
    \EndIf
\EndFunction

\Function{eval-gep}{$\tau, p, j_0, \overline{j}$}
    \State $o \gets \bvmul{\bvsort{32}}{\bvsext_{32}(j_0)}{\bvconst{32}{|\tau|}}$ \label{line:first-index}
    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
    \State \Return $\bvadd{\bvsort{64}}{p}{\bvzext_{64}(r)}$
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Interface Lemmas}

In this section,
we provide the formalization of the interface lemmas for $\tload$, $\tstore$, and $\tgep$.

\begin{definition}
\label{def:sym-well-formed}
A memory object $(\addr, \size, \smtarray)$ is well-formed if its address interval does not wrap around the address space,
\ie $a + \zeroext_{\bvsort{64}}(s)$ does not overflow.
A heap $\symmemory$ is well-formed if all its memory objects are well-formed and there are no memory objects with overlapping address intervals.
A symbolic state $\symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$ is well-formed if $\symmemory$ is well-formed.
\end{definition}

\begin{lemma}
\label{lemma:interface-load}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e}$}.
If there exist $\symmo$, $\symlocalstore'_{opt}$, and $t$ such that:
\begin{enumerate}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}} = p$
    \item $\unsat(\pc \land \neg \rangecond(p, |\tau|, \symmo))$
    \item $\symlocalstore[x \mapsto \moRead{\symmo}{p}{\tau}] \equiv \symlocalstore'_{opt}$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\begin{lemma}
\label{lemma:interface-store}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2}$}.
If there exist $\symmo$, $\symmo'_{opt}$, and $t$ such that:
\begin{enumerate}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e_1}{\symlocalstore}{\tau} = v$
    \item $\evalexprty{e_2}{\symlocalstore}{\bvsort{64}} = \bvconst{64}{p}$
    \item $\isinbounds{\bvval{p}{64}}{|\tau|}{\symmo}$
    \item $\symmo'_{opt} \equiv \moWrite{\symmo}{\bvconst{64}{p}}{v}$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\heapReplace{\symmemory}{\symmo}{\symmo'_{opt}}}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\begin{lemma}
\label{lemma:interface-gep}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}$}.
If there exist $\symlocalstore'_{opt}$ and $t$ such that:
\begin{enumerate}
    \item $\evalexprty{e_i}{\symlocalstore}{\tau_i} = k_i$
    \item $\unsat(\pc \land \overflowcond(\tau, \overline{k_i}))$
    \item \textup{$\symlocalstore[x \mapsto \evalexprty{\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}{\symlocalstore}{\tau^{*}}] \equiv \symlocalstore'_{opt}$}
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\section{Evaluation}
\label{appendix:evaluation}

\subsection{Benchmarks}
\label{appendix:benchmarks}

\begin{table*}[t]
\centering
\begin{tabular}{|l|l|r|}
\hline
\textbf{Library} & \textbf{Version} & \textbf{\#Subjects} \\
\hline
\libtasn & 4.16.0 & 6 \\
\hline
\libosip & 5.2.1 & 7 \\
\hline
\coreutils & 9.7 & 7  \\
\hline
\svcomp & latest & 22 \\
\hline
\end{tabular}
\caption{Benchmarks.}
\label{table:benchmarks}
\end{table*}

\Cref{table:benchmarks} shows the version of each benchmark and the number of subjects in each benchmark.

\subsection{Results}
\label{appendix:results}
\Cref{table:extended-results} shows the detailed results for each subject.

\begin{table*}[t]
\small{
\begin{tabular}{|l|l|r|r|r|r|r|r|}
\hline
\textbf{Benchmark} & \textbf{Subject} & \makecell{\textbf{Time}} & \makecell{\textbf{Time}} & \makecell{\textbf{Proof}} & \makecell{\textbf{Proof}} & \textbf{\#Inst} & \textbf{\#Path} \\
& & \makecell{\textbf{\base}} & \makecell{\textbf{\proofopt}} & \makecell{\textbf{Time}} & \makecell{\textbf{Size}} & & \\
\hline
\libtasn & test\_asn1\_bit\_der & 4.3 & 5.0 & 160.4 & 32111 & 10004 & 301 \\
& test\_asn1\_get\_length\_ber & 8.0 & 12.7 & 201.9 & 109704 & 32019 & 456 \\
& test\_asn1\_get\_length\_der & 0.8 & 1.0 & 31.7 & 6855 & 1897 & 92 \\
& test\_asn1\_get\_object\_id\_der & 2.6 & 5.7 & 628.4 & 136632 & 44573 & 266 \\
& test\_asn1\_get\_octet\_der & 4.0 & 4.6 & 166.3 & 32013 & 9619 & 282 \\
& test\_asn1\_get\_tag\_der & 0.5 & 0.7 & 47.2 & 10981 & 2412 & 51 \\
\hline
\libosip & test\_osip\_dequote & 0.1 & 0.2 & 20.4 & 5037 & 1997 & 32 \\
& test\_osip\_hash & 0.1 & 0.1 & 1116.6 & 1158 & 532 & 21 \\
& test\_osip\_str\_append & 0.1 & 0.2 & 8.4 & 2007 & 769 & 21 \\
& test\_osip\_strcasecmp & 0.2 & 0.2 & 16.7 & 4134 & 1844 & 41 \\
& test\_osip\_strncasecmp & 0.3 & 0.3 & 15.6 & 3816 & 1397 & 40 \\
& test\_osip\_strncpy & 0.1 & 0.1 & 22.6 & 5915 & 1933 & 21 \\
& test\_osip\_tolower & 0.1 & 0.1 & 8.6 & 1399 & 628 & 21 \\
\hline
\coreutils & test\_base32 & 0.1 & 0.1 & 25.3 & 5089 & 665 & 1 \\
& test\_base64 & 0.1 & 0.1 & 19.8 & 4576 & 709 & 1 \\
& test\_base\_len & 0.1 & 0.2 & 30.6 & 7280 & 3629 & 211 \\
& test\_hash\_pjw & 0.1 & 0.1 & 1104.5 & 1474 & 663 & 21 \\
& test\_last\_component & 0.1 & 0.1 & 11.7 & 2838 & 1218 & 63 \\
& test\_strintcmp & 0.6 & 1.4 & 163.1 & 42527 & 13517 & 275 \\
& test\_strip\_trailing\_slashes & 0.1 & 0.2 & 40.2 & 9570 & 4842 & 63 \\
\hline
\svcomp & bubblesort-alloca-2 & 0.2 & 0.3 & 25.0 & 5584 & 1910 & 24 \\
& cstrchr-alloca-2 & 0.2 & 0.3 & 5.0 & 1121 & 513 & 38 \\
& cstrcmp-alloca-2 & 0.1 & 0.2 & 7.8 & 1869 & 761 & 37 \\
& cstrcpy-alloca-1 & 0.1 & 0.1 & 3.1 & 608 & 258 & 10 \\
& cstrcspn-alloca-1 & 4.9 & 6.8 & 147.7 & 34291 & 12848 & 460 \\
& cstrlen-alloca-2 & 0.1 & 0.1 & 2.8 & 525 & 252 & 10 \\
& cstrncat-alloca-2 & 0.1 & 0.1 & 1.4 & 113 & 24 & 3 \\
& cstrncmp-alloca-1 & 0.3 & 0.3 & 8.6 & 2036 & 780 & 41 \\
& cstrncpy-alloca-2 & 0.1 & 0.1 & 7.6 & 1748 & 716 & 10 \\
& cstrpbrk-alloca-2 & 0.7 & 0.9 & 17.7 & 4318 & 1662 & 64 \\
& cstrspn-alloca-1 & 0.7 & 0.9 & 20.1 & 4990 & 1918 & 64 \\
& diff-alloca-2 & 5.2 & 7.5 & 398.4 & 96115 & 32558 & 625 \\
& insertionsort-alloca-1 & 0.2 & 0.2 & 12.9 & 2736 & 955 & 24 \\
& java\_BubbleSort-alloca-1 & 0.2 & 0.3 & 23.6 & 5212 & 1764 & 24 \\
& lis-alloca-1 & 0.3 & 0.5 & 46.2 & 12737 & 3292 & 24 \\
& mult\_array-alloca-1 & 0.1 & 0.3 & 43.3 & 10789 & 1526 & 1 \\
& rec\_strlen-alloca-1 & 0.1 & 0.1 & 3.6 & 751 & 401 & 10 \\
& selectionsort-alloca-1 & 0.3 & 0.5 & 35.0 & 7861 & 2540 & 33 \\
& stroeder1-alloca-1 & 0.1 & 0.1 & 3.3 & 648 & 258 & 1 \\
& strreplace-alloca-2 & 7.3 & 8.7 & 148.7 & 35976 & 15466 & 1023 \\
& subseq-alloca-2 & 1.7 & 3.9 & 351.4 & 85773 & 33988 & 1790 \\
& substring-alloca-2 & 0.2 & 0.3 & 11.5 & 2701 & 1037 & 32 \\
\hline
\end{tabular}
}
\caption{Extended results for each subject.}
\label{table:extended-results}
\end{table*}
