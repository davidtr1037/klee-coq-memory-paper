\section{Module Assumptions}
\label{appendix:module-assumptions}
If the indexed type of a given index in a $\tgep$ instruction is a struct type,
then that index must be a constant and lie within the range of $\bvsort{64}$.

\section{Concrete Semantics}
\label{appendix:concrete-semantics}
% TODO: handle the struct case
The semantics of the $\tgep$ instruction is given in~\Cref{alg:gep}.

\begin{algorithm}[t]
\caption{The semantics of $\tgep$ (without attributes).}
\label{alg:gep}
\begin{algorithmic}[1]

\Function{compute-offset}{$\tau, o, \overline{j}$}
    \If {$|\overline{j}| = 0$}
        \State \Return $o$
    \EndIf
    \State $\overline{j} \gets j_1 :: \overline{j'}$
    \If {$\tau = \arraytype{\tau'}{n}$}
        \State $o \gets o + \convert_{\indextype}(j_1) \cdot \valoftype{|\tau'|}{\indextype}$ \label{line:array-index}
        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
    \EndIf
    \If {$\tau = \structtype{\tau}{n}$}
        \State ...
    \EndIf
    \State ...
\EndFunction

\Function{eval\_gep}{$\tau, p, \overline{j}$}
    \If {$\tpoison \in \overline{j}$}
        \State \Return $\tpoison$
    \EndIf
    \If {$\tundef \in \overline{j}$}
        \State \Return $\tundef$
    \EndIf
    \State $j_0 :: \overline{j} \gets \overline{j}$
    \State $o \gets \convert_{\indextype}(j_0) \cdot \valoftype{|\tau|}{\indextype}$ \label{line:first-index}
    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
    \State \Return $p + \zeroext_{\pointertype}(r)$
\EndFunction

\end{algorithmic}
\end{algorithm}

\section{Interface Lemmas}

\begin{definition}
\label{def:sym-well-formed}
A memory object $(\addr, \size, \smtarray)$ is well-formed if its address interval does not wrap around the address space,
\ie $a + \zeroext_{\bvsort{64}}(s)$ does not overflow.
A memory $\symmemory$ is well-formed if all the memory objects are well-formed and there are no memory objects with overlapping address intervals.
A symbolic state $\symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$ is well-formed if $\symmemory$ is well-formed.
\end{definition}

\begin{lemma}
\label{lemma:interface-store}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2}$}.
If there exist $\symmo$, $\symmo'_{opt}$, and $t$ such that:
\begin{enumerate}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e_1}{\symlocalstore}{\tau} = v$
    \item $\evalexprty{e_2}{\symlocalstore}{\bvsort{64}} = \bvconst{64}{p}$
    \item $\isinbounds{\bvval{p}{64}}{|\tau|}{\symmo}$
    \item $\symmo'_{opt} \equiv \moWrite{\symmo}{\bvconst{64}{p}}{.}{v}$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\heapReplace{\symmemory}{\symmo}{\symmo'_{opt}}}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\begin{lemma}
\label{lemma:interface-gep}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}$}.
If there exist $\symlocalstore'_{opt}$ and $t$ such that:
\begin{enumerate}
    \item $\evalexprty{e_i}{\symlocalstore}{\tau_i} = k_i$
    \item $\unsat(\pc \land \overflowcond(\tau, \overline{k_i}))$
    \item \textup{$\symlocalstore[x \mapsto \evalexprty{\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}{\symlocalstore}{\tau^{*}}] \equiv \symlocalstore'_{opt}$}
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\begin{lemma}
\label{lemma:interface-load}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e}$}.
If there exist $\symmo$, $\symlocalstore'_{opt}$, and $t$ such that:
\begin{enumerate}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}} = p$
    \item $\unsat(\pc \land \neg \rangecond(p, |\tau|, \symmo))$
    \item $\symlocalstore[x \mapsto \moRead{\symmo}{p}{\tau}] \equiv \symlocalstore'_{opt}$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\section{Evaluation}
\label{appendix:evaluation}

\subsection{Benchmarks}
\label{appendix:benchmarks}

\begin{table*}[t]
\caption{Benchmarks.}
\label{table:benchmarks}
\centering
\begin{tabular}{|l|l|r|}
\hline
\textbf{Library} & \textbf{Version} & \textbf{\#Subjects} \\
\hline
\libtasn & 4.16.0 & 6 \\
\hline
\libosip & 5.2.1 & 7 \\
\hline
\coreutils & 9.7 & 7  \\
\hline
\svcomp & latest & 22 \\
\hline
\end{tabular}
\end{table*}

\Cref{table:benchmarks} shows the version of each benchmark and the number of subjects in each benchmark.
