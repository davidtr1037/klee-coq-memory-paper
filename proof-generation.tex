\section{Proof Generation}
\label{sec:proof-generation}

This section will be a bit KLEE-specific,
but we can claim that our approach can be adapted for other implementations as well.

\subsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects.
A memory object is associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequence of store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

\subsection{Proving Safety of Steps}
% TODO: Proving Safety of Steps using Interface Lemmas?
% TODO: explain the concept of interface lemmas
% TODO: use \bvconst instead of regular constants?
% TODO: in this section: iptr = i64 / iidx = i32

% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for malloc
% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% example for free
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

\subsubsection{Symbolic State Translation.}
% TODO: explain how to translate the heap/memory
The translation of a memory object from its internal representation to its representation in \coq works as follows.
In the case of an optimized representation,
the internal mapping $\{0 \mapsto e_0, 1 \mapsto e_1, \ldots\}$ is translated to a sequence of store expressions:
\[ \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{e_0}}{\bvconst{32}{1}}{e_1} \ldots \]
In the case of a non-optimized representation,
we directly translate the sequence of store expressions used internally to a sequence of store expressions in \coq.

\subsubsection{Example: Malloc}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ \}}
    {[]}
    {(\_, [])}
    {\true}
\]
According to the symbolic semantics, any derived symbolic state should have the following form:
\[
s' \triangleq \symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    %{(\_, [(\addr, 10, \arrayconst{\arrayinitvalue})])}
    {\memory'}
    {\true}
\]
where there exists an SMT model $m$ such that $m[\evalexprty{e}{\symlocalstore}{\tau}] = n$ and $\allocate(..., n) = (\memory', \bvconst{64}{\addr})$.

At this point, the representation of the allocated memory object is optimized, as no stores have been performed yet,
so the symbolic state computed by the \SE engine is:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {(\_, [(\addr, 10, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue})])}
    {\true}
\]
The two symbolic states are identical up to the encoding of the SMT array of the allocated memory object.
However, these two SMT arrays are equivalent,
since all the additional store expressions contain the same value $v$ as in $\arrayconst{v}$.
Therefore, the two symbolic states are equivalent as well.
% TODO: why safe?
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{64}}~\intrinsicfunc{malloc}(e)}$},
and let $b \triangleq \nfa{\memory}$.
If there exist $n$, $\mo$, and $t$ such that:
\begin{itemize}
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}} \equiv \bvval{n}{64} \land n < max\_signed_{\bvsort{32}}$
    \item $\mo \equiv (\bvval{b}{32}, \bvval{n}{32}, \arrayconst{\arrayinitvalue})$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \bvconst{32}{b}]}{\symstack}{\memory \mathbin{++} [\mo]}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: GetElementPtr}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvconst{64}{0}), \bvconst{32}{1}))) \}}
    {[]}
    {...}
    {n < 2}
\]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {...}
    {n < 2}
\]

\subsubsection{Example: Store}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\addr, 10, \smtarray_0)]}
    {n < 2}
\]
where:
\[\smtarray_0 \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: there might be multiple derivations
% TODO: the derived state is parametric
% TODO: the type is i8, so we add a single store expression
% TODO: fix the index expression
On one side, according to the symbolic semantics,
any derived symbolic state should have the following form:
\[
s' \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    %{[(\addr, 10, \smtarray_1)])}
    {[\symmo]}
    {n < 2 \land \rangecond(\bvconst{64}{\addr}, 1, \symmo)}
\]
where there is an SMT model $m$ and a memory object $\mo$ such that $m \models \pc$ and $\mo \in \symmemory$.
%\[ \smtarray_1 \triangleq \arraystore{\smtarray_0}{(\bvconst{64}{\addr} - \bvconst{64}{\addr})}{\bvconst{8}{7}} \]
% The representation of the updated memory object is optimized, ...
% offset computation
% mapping
On the other side, the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\addr, 10, \smtarray_1^{'})]}
    {n < 2}
\]
where:
\[ \smtarray_1^{'} \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: note the change at offset 1
Now, we have to show that the two symbolic states are equivalent.
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2}$}.
If there exist $\mo$ and $t$ such that:
\begin{itemize}
    \item $\symmemory$ is well-formed
    \item $\mo \in \symmemory$
    \item $\evalexprty{e_1}{\symlocalstore}{\tau} = v$
    \item $\evalexprty{e_2}{\symlocalstore}{\bvsort{64}^{*}} = \bvconst{64}{p}$
    \item $\isinbounds(\bvval{p}{64}, |\tau|, \mo)$
    \item $\mo'_{opt} \equiv \writemo(\mo, \bvconst{64}{p}, v)$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\replace(\symmemory, \mo'_{opt})}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: GetElementPtr (2)}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvzext_{64}(n)), \bvconst{32}{1}))) \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\subsubsection{Example: Load}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2 \land \rangecond(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), 1, \symmo)}
\]
where:
% TODO: should add 0_{32}?
\[ e \triangleq \bvextract_{32}(\bvsub_{64}(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), \bvconst{64}{\addr})) \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ e \triangleq \bvextract_{32}(\bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\begin{figure}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\caption{A simple \llvm IR program.}
\label{figure:example-llvm}
\end{figure}

\subsection{Optimizations}
\begin{itemize}
    \item reusing terms (memory, ...)
    \item specialized lemmas (interface lemmas)
    \item ...
\end{itemize}

% similarly to ..., we reuse terms to accelerate the ...
% here, we extend this approach to handle ..
% more spec., ...
% what about interface lemmas?
