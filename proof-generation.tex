\section{Proof Generation}
\label{sec:proof-generation}

This section will be a bit KLEE-specific,
but we can claim that our approach can be adapted for other implementations as well.

\subsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects.
A memory object is associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequence of store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

\subsection{Proving Safety of Steps}
% TODO use \bvconst instead of regular constants?

% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for malloc
% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% example for free
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

\subsubsection{Symbolic State Translation.}
The translation of a memory object from its internal representation to its representation in \coq works as follows.
In the case of an optimized representation,
the internal mapping $\{0 \mapsto e_0, 1 \mapsto e_1, \ldots\}$ is translated to a sequence of store expressions:
\[ \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{e_0}}{\bvconst{32}{1}}{e_1} \ldots \]
In the case of a non-optimized representation,
we directly translate the sequence of store expressions used internally to a sequence of store expressions in \coq.

\subsubsection{Example: Malloc}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ \}}
    {[]}
    {(\_, [])}
    {\true}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {(\_, [(\addr, 10, \arrayconst{\arrayinitvalue})])}
    {\true}
\]
At this point, the representation of the allocated memory object is optimized, as no stores have been performed yet,
so the symbolic state computed by the \SE engine is:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {(\_, [(\addr, 10, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue})])}
    {\true}
\]
The two symbolic states are identical up to the encoding of the SMT array of the allocated memory object.
However, these two SMT arrays are equivalent,
since all the additional store expressions contain the same value $v$ as in $\arrayconst{v}$.
Therefore, the two symbolic state are equivalent as well.
% TODO: why safe?

\subsubsection{Example: GetElementPtr}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvconst{64}{0}), \bvconst{32}{1}))) \}}
    {[]}
    {...}
    {n < 2}
\]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {...}
    {n < 2}
\]

\subsubsection{Example: Store}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray_0)])}
    {n < 2}
\]
where:
\[\smtarray_0 \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray_1)])}
    {n < 2 \land \rangecond(\bvconst{64}{\addr}, 1, \symmo)}
\]
where:
\[ \smtarray_1 \triangleq \arraystore{\smtarray_0}{\bvconst{64}{(\addr + 1)} - \bvconst{64}{\addr}}{\bvconst{8}{7}} \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray_1^{'})])}
    {n < 2}
\]
where:
\[ \smtarray_1^{'} \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: note the change at offset 1

\subsubsection{Example: GetElementPtr (2)}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvzext_{64}(n)), \bvconst{32}{1}))) \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\subsubsection{Example: Load}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2 \land \rangecond(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), 1, \symmo)}
\]
where:
% TODO: should add 0_{32}?
\[ e \triangleq \bvextract_{32}(\bvsub_{64}(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), \bvconst{64}{\addr})) \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ e \triangleq \bvextract_{32}(\bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\begin{figure}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\caption{A simple \llvm IR program.}
\label{figure:example-llvm}
\end{figure}

\subsection{Optimizations}
\begin{itemize}
    \item reusing terms (memory, ...)
    \item specialized lemmas (interface lemmas)
    \item ...
\end{itemize}

% similarly to ..., we reuse terms to accelerate the ...
% here, we extend this approach to handle ..
% more spec., ...
% what about interface lemmas?
