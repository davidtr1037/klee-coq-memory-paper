\section{Proof Generation}
\label{sec:proof-generation}

This section will be a bit KLEE-specific,
but we can claim that our approach can be adapted for other implementations as well.

\subsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects.
A memory object is associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequece of SMT store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

\subsection{Proving Safety of Steps}
% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for malloc
% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% example for free
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

\subsubsection{Example: Malloc}
The initial symbolic state:
\[
\symstate
    {...}
    {\{ \}}
    {[]}
    {(\_, [])}
    {\true}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \addr_0 \}}
    {[]}
    {(\_, [(\addr_0, 10, \arrayconst{\arrayinitvalue})])}
    {\true}
\]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \addr_0 \}}
    {[]}
    {(\_, [(\addr_0, 10, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{0}{\arrayinitvalue}}{1}{\arrayinitvalue})])}
    {\true}
\]

\subsubsection{Example: Store}
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr_0, 10, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{0}{\arrayinitvalue}}{1}{\arrayinitvalue})])}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray_1)])}
    {n < 2 \land \rangecond(\addr_0, 1, \symmo)}
\]
where:
\[ \smtarray_1 \triangleq \arraystore{\arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{0}{\arrayinitvalue}}{1}{\arrayinitvalue}}{(\addr_0 + 1) - \addr_0}{7} \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray_1^{'})])}
    {n < 2}
\]
where:
\[ \smtarray_1^{'} \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{0}{7}}{1}{\arrayinitvalue}\]
% TODO: note the change at offset 1

\begin{figure}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\caption{A simple \llvm IR program.}
\label{figure:example-llvm}
\end{figure}

\subsection{Optimizations}
\begin{itemize}
    \item reusing terms (memory, ...)
    \item specialized lemmas (interface lemmas)
    \item ...
\end{itemize}
