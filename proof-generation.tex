\section{Proof Generation}
\label{sec:proof-generation}

TBD implies that if there exists an execution tree that satisfies the premise of the theorem,
then we can obtain a safety proof of the input program.
In this section, we show how to compute such execution trees and how to prove their desired properties.
% TODO: mention the section?
Our approach is based on X, which works as an instrumentation of the \SE engine, and we extend it to support memory operations.
Our approach generates a \coq proof that consists of a pre-defined section and an auto-generated section.
The pre-defined section is written manually and it contains the various definitions that were given in ...:
concrete semantics, symbolic semantics, etc.
The auto-generated section is generated by the \SE engine during the analysis of the given program,
and it contains definitions that are specific to that program:
module definitions, symbolic states, execution tree, etc.

In this section, we present our approach using \klee as the underlying \SE engine.
However, we note that our approach can be adapted to other \SE implementations as well.
Before diving into the details,
we give some background about the memory modeling in \klee.

\subsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects.
A memory object is associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequence of store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

\begin{figure}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\caption{A simple \llvm IR program.}
\label{figure:example-llvm}
\end{figure}

\subsection{Proving Execution Tree Safety using Interface Lemmas}
% TODO: explain how we prove the the ET is safe
% TODO: explain the concept of interface lemmas (why needed? ...)
% TODO: use \bvconst instead of regular constants?
% TODO: in this section: iptr = i64 / iidx = i32

% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for malloc
% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% example for free
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

\subsubsection{Symbolic State Translation.}
% TODO: explain how to translate the heap/memory
The translation of a memory object from its internal representation to its representation in \coq works as follows.
In the case of an optimized representation,
the internal mapping $\{0 \mapsto e_0, 1 \mapsto e_1, \ldots\}$ is translated to a sequence of store expressions:
\[ \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{e_0}}{\bvconst{32}{1}}{e_1} \ldots \]
In the case of a non-optimized representation,
we directly translate the sequence of store expressions used internally to a sequence of store expressions in \coq.

\subsubsection{Example: Malloc}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ \}}
    {[]}
    {(\_, [])}
    {\true}
\]
According to the symbolic semantics, any derived symbolic state should have the following form:
\[
s' \triangleq \symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    %{(\_, [(\addr, 10, \arrayconst{\arrayinitvalue})])}
    {\memory'}
    {\true}
\]
where there exists an SMT model $m$ such that $m[\evalexprty{e}{\symlocalstore}{\tau}] = n$ and $\allocate(..., n) = (\memory', \bvconst{64}{\addr})$.

At this point, the representation of the allocated memory object is optimized, as no stores have been performed yet,
so the symbolic state computed by the \SE engine is:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {(\_, [(\addr, 10, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue})])}
    {\true}
\]
The two symbolic states are identical up to the encoding of the SMT array of the allocated memory object.
However, these two SMT arrays are equivalent,
since all the additional store expressions contain the same value $v$ as in $\arrayconst{v}$.
Therefore, the two symbolic states are equivalent as well.
% TODO: why safe?
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{64}}~\intrinsicfunc{malloc}(e)}$},
and let $b \triangleq \nfa{\memory}$.
If there exist $n$, $\symmo$, and $t$ such that:
\begin{itemize}
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}} \equiv \bvval{n}{64} \land n < max\_signed_{\bvsort{32}}$
    \item $\symmo \equiv (\bvval{b}{64}, \bvval{n}{32}, \arrayconst{\arrayinitvalue})$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \bvconst{64}{b}]}{\symstack}{\memory \mathbin{++} [\symmo]}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: GetElementPtr}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
According to the symbolic semantics, the derived symbolic state is:
\[
s' \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvconst{64}{0}), \bvconst{32}{1}))) \}}
    {[]}
    {...}
    {n < 2}
\]
The symbolic state computed by the \SE engine:
\[
s'_{opt} \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {...}
    {n < 2}
\]
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}$}.
If there exist $\symlocalstore'_{opt}$ and $t$ such that:
\begin{itemize}
    \item $\evalexprty{e_i}{\symlocalstore}{\tau_i} = k_i$
    \item $\unsat(\overflowcond(\tau, \overline{k_i}))$
    \item \textup{$\symlocalstore'_{opt} \equiv \symlocalstore[x \mapsto \evalexprty{\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}{\symlocalstore}{\tau^{*}}]$}
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: Store}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\addr, 10, \smtarray_0)]}
    {n < 2}
\]
where:
\[\smtarray_0 \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: there might be multiple derivations
% TODO: the derived state is parametric
% TODO: the type is i8, so we add a single store expression
% TODO: fix the index expression
On one side, according to the symbolic semantics,
any derived symbolic state should have the following form:
\[
s' \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    %{[(\addr, 10, \smtarray_1)])}
    {[\symmo]}
    {n < 2 \land \rangecond(\bvconst{64}{\addr}, 1, \symmo)}
\]
where there is an SMT model $m$ and a memory object $\symmo$ such that $m \models \pc$ and $\symmo \in \symmemory$.
%\[ \smtarray_1 \triangleq \arraystore{\smtarray_0}{(\bvconst{64}{\addr} - \bvconst{64}{\addr})}{\bvconst{8}{7}} \]
% The representation of the updated memory object is optimized, ...
% offset computation
% mapping
On the other side, the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\addr, 10, \smtarray_1^{'})]}
    {n < 2}
\]
where:
\[ \smtarray_1^{'} \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: note the change at offset 1
Now, we have to show that the two symbolic states are equivalent.
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2}$}.
If there exist $\symmo$ and $t$ such that:
\begin{itemize}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e_1}{\symlocalstore}{\tau} = v$
    \item $\evalexprty{e_2}{\symlocalstore}{\bvsort{64}^{*}} = \bvconst{64}{p}$
    \item $\isinbounds(\bvval{p}{64}, |\tau|, \symmo)$
    \item $\symmo'_{opt} \equiv \writemo(\symmo, \bvconst{64}{p}, v)$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\replace(\symmemory, \symmo'_{opt})}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: GetElementPtr (2)}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvzext_{64}(n)), \bvconst{32}{1}))) \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\subsubsection{Example: Load}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2 \land \rangecond(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), 1, \symmo)}
\]
where:
% TODO: should add 0_{32}?
\[ e \triangleq \bvextract_{32}(\bvsub_{64}(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), \bvconst{64}{\addr})) \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ e \triangleq \bvextract_{32}(\bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e}$}.
If there exist $\symmo$ and $t$ such that:
\begin{itemize}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}^{*}} = \bvconst{64}{p}$
    \item $\isinbounds(\bvval{p}{64}, |\tau|, \symmo)$
    \item $\symlocalstore'_{opt} \equiv \symlocalstore[x \mapsto \readmo(\symmo, \bvconst{64}{p}, |\tau|)]$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsection{Optimizations}
\begin{itemize}
    \item reusing terms (memory, ...)
    \item specialized lemmas (interface lemmas)
    \item ...
\end{itemize}

% similarly to ..., we reuse terms to accelerate the ...
% here, we extend this approach to handle ..
% more spec., ...
% what about interface lemmas?
