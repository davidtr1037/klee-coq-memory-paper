% TODO: proof logging?
\subsection{Proof Generation}
\label{sec:proof-generation}

\Cref{theorem:safety-via-et} implies that the existence of a safe execution tree guarantees program safety.
This result is crucial, as it provides the foundation for constructing safety proofs.
In this section, we show how to compute such execution trees and how to prove their desired properties.
% TODO: mention the section?
Our approach is based on~\cite{klee-rocq}, which works as an instrumentation of the \SE engine, and we extend it to support memory operations.
Our approach generates a \coq proof that consists of a pre-defined section and an auto-generated section.
The pre-defined section is written manually and it contains the various definitions that were given in~\Cref{sec:background,sec:core}:
concrete semantics, symbolic semantics, etc.
The auto-generated section is generated by the \SE engine during the analysis of the given program,
and it contains definitions that are specific to that program:
module definitions, symbolic states, execution tree, etc.

In this section, we present our approach using \klee~\cite{klee} as the underlying \SE engine.
However, we note that our approach can be adapted to other \SE implementations as well.
Before diving into the details,
we give some background about the internals of the memory modeling in \klee.

\subsubsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects,
each associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequence of store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

For example, after executing~\cref{line:example-store} of the C program in~\Cref{figure:example-llvm},
the contents of the memory object allocated at~\cref{line:example-malloc} are encoded using the optimized representation as $\{ 0 \mapsto \bvconst{8}{7}, 1 \mapsto \bvconst{8}{0} \}$.
If afterwards, we were to execute the instruction \code{p[n] = 1},
then we would switch to the non-optimized representation, resulting in the following encoding:
$\arraystore{\arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\bvconst{8}{0}}}{n}{\bvconst{8}{1}}$.

\begin{figure}
\begin{minipage}[t]{0.60\columnwidth}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\end{minipage}
\begin{minipage}[t]{0.38\columnwidth}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=c,mathescape=true,breaklines=false]{code/example.simple.c}
\end{minipage}
\caption{A simple C program (right) and a snippet from its \llvm IR (left).}
\label{figure:example-llvm}
\end{figure}

\subsubsection{Translating Modules and Symbolic States}
The translation of the \llvm module, along with the proof showing that the module assumptions hold (\Cref{sec:core}),
is done similarly to~\cite{klee-rocq}.
The symbolic states generated by the \SE engine are translated to their appropriate definitions in \coq based on~\Cref{def:symbolic-state}.
The translation of a memory object in \klee's internal representation to \coq works as follows.
In the case of an optimized representation,
the internal mapping $\{0 \mapsto e_0, 1 \mapsto e_1, \ldots\}$ is translated to a sequence of store expressions in \coq:
\[ \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{e_0}}{\bvconst{32}{1}}{e_1} \ldots \]
In the case of a non-optimized representation,
the internal sequence of store expressions is directly translated to a sequence of store expressions in \coq.
Accordingly, the internal heap is translated into a list of memory objects in \coq.
The translation of other components is done similarly to~\cite{klee-rocq}.

\subsubsection{Proving Execution Tree Safety using Interface Lemmas}
% TODO: explain how we prove the the ET is safe
% TODO: explain the concept of interface lemmas (why needed? ...)
% TODO: use \bvconst instead of regular constants?
% TODO: in this section: iptr = i64 / iidx = i32
% TODO: an example of ET def?

% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

First, we generate the definition of the execution tree in a bottom-up manner.
Then, we have to prove that the resulting execution tree satisfies the $\safeet$ relation.
We generate this proof in a bottom-up manner as well, showing that each subtree satisfies the required properties.
The proof of each subtree corresponds to a single instruction that was executed during the analysis.
Generating an explicit proof from scratch for each subtree is expensive in terms of proof generation,
and it also makes the proof checking inefficient,
as such a proof requires expensive \coq tactics such as: \textit{inversion}, \textit{subst}, \etc
Instead, we adapt the approach proposed in~\cite{klee-rocq},
and create for each instruction type a generic lemma that can be used to infer execution tree safety.
We call these lemmas \emph{interface} lemmas,
as they facilitate an effective interaction between the pre-defined and auto-generated sections of the proof.
By using such interface lemmas,
we accelerate both proof generation and proof checking,
since we create smaller proofs which mainly rely on simple tactics such as \textit{apply} and \textit{reflexivity}.

Now, we will show how to define such interface lemmas,
and how to apply them in the context of the \llvm IR program from~\Cref{figure:example-llvm}.
In this section, we will focus on memory-related instructions.
We denote by $\location_n$ the program location that corresponds to line $n$ in~\Cref{figure:example-llvm}.

\subsubsection{\textit{Example: Malloc.}}
The initial symbolic state at~\cref{line:llvm-malloc} is $s \triangleq \symstate{\location_1}{\{ \}}{[]}{[]}{\true}$.
%\[
%s \triangleq \symstate
%    {\location_1}
%    {\{ \}}
%    {[]}
%    {[]}
%    {\true}
%\]
In general, the \rulenameref{Malloc} rule may result in multiple derivations,
but in this case, the size argument of \textit{malloc} is evaluated to a constant SMT expression,
so the only derived symbolic state is $s' \triangleq \symstate{\location_2}{\{ \nameid{p} \mapsto \bvconst{64}{\addr} \}}{[]}{[(\bvval{\addr}{64}, \bvval{2}{32}, \arrayconst{\arrayinitvalue})]}{\true}$,
%\[
%s' \triangleq \symstate
%    {\location_2}
%    {\{ \nameid{p} \mapsto \bvconst{64}{\addr} \}}
%    {[]}
%    {[(\bvval{\addr}{64}, \bvval{2}{32}, \arrayconst{\arrayinitvalue})]}
%    {\true}
%\]
where $\bvval{\addr}{64}$ is the allocated base address.
At this point, the \SE engine uses an optimized representation for the allocated memory object, as no stores have been performed yet,
so the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {\location_2}
    {\{ \nameid{p} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\bvval{\addr}{64}, \bvval{2}{32}, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue})]}
    {\true}
\]
Now, we have to prove that the subtree of $s$ is safe.
Note that $\evalexprty{2}{\symlocalstore}{\bvsort{64}} = \bvconst{64}{2}$,
so $s$ is not an error state.
To prove that $s' \equiv s'_{opt}$,
it suffices to prove that their memory is equivalent.
The SMT arrays in those two symbolic states are encoded differently,
but they are actually equivalent, since the additional store expressions contain the same value $\arrayinitvalue$ as in $\arrayconst{\arrayinitvalue}$.

To handle such cases in general, we define an interface lemma for \textit{malloc}, which is stated as~\Cref{lemma:interface-malloc}.
In this case, we can apply~\Cref{lemma:interface-malloc} with $n$ as 2, $\symmo$ as the memory object from $s'_{opt}$, and $t$ as the subtree of $s'_{opt}$.
% TODO: show why the preconditions hold?

Note that this lemma assumes that the size argument of \textit{malloc} is evaluated to a concrete SMT expression.
If that is not the case,
then the \SE engine concretizes the symbolic expression,
and then the analysis may be incomplete and a safety proof may not be derivable.
There exist \SE engines that support symbolic-size allocations (\eg \cite{symsize-model}),
however, it is not the focus of this work.

\begin{lemma}
\label{lemma:interface-malloc}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{64}}~\intrinsicfunc{malloc}(e)}$},
and let $\bvval{\addr}{64}$ be the allocated base address.
If there exist $n$, $\symmo$, and $t$ such that:
\begin{enumerate}
    \item \textup{$\evalexprty{e}{\symlocalstore}{\bvsort{64}} \equiv \bvconst{64}{n}$} and \textup{$\bvval{n}{64} < \bvval{(2^{\indexwidth - 1} - 1)}{64}$}
    \item \textup{$\symmo \equiv (\bvval{\addr}{64}, \bvval{n}{32}, \arrayconst{\arrayinitvalue})$}
    \item \textup{$t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \bvconst{64}{\addr}]}{\symstack}{\symmo :: \symmemory}{\pc}$}
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

Due to space limitations,
the interface lemmas for the rest of the examples are defined in the appendix (\Cref{lemma:interface-store,lemma:interface-gep,lemma:interface-load}).
\subsubsection{\textit{Example: Store.}}
% TODO: explain how to prove that this is not an error state
% TODO: the type is i8, so we add a single store expression
% TODO: fix the index expression
The symbolic state at~\cref{line:llvm-store} is:
\[
s \triangleq \symstate
    {\location_6}
    {\{ ..., \nameid{gep1} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[\symmo]}
    {n < \bvconst{32}{2}}
\]
where:
\[ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue}, \ \symmo \triangleq (\bvval{\addr}{64}, \bvval{2}{32}, \smtarray) \]

On one side, according to the symbolic semantics,
if $s'$ is derived from $s$ then there exist a model $m$ and a memory object $\symmo'$ such that
$m \models \pc$, $\symmo' \in \symmemory$, and $\symisinbounds{\bvconst{64}{\addr}}{\bvsort{8}}{\symmo'}{m}$, and then:
\[
s' \triangleq \symstate
    {\location_7}
    {\{ ..., \nameid{gep1} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[\moWrite{\symmo'}{\bvconst{64}{\addr}}{\bvconst{8}{7}}]}
    {n < \bvconst{32}{2} \land \rangecond(\bvconst{64}{\addr}, 1, \symmo'))}
\]
Recall that we assume that address intervals of memory objects do not overlap.
Since $\symmo' \in \symmemory$ and $\symisinbounds{\bvconst{64}{\addr}}{\bvsort{8}}{\symmo'}{m}$,
then it must hold that $\symmo' = \symmo$, since $\bvconst{64}{\addr}$ is a constant SMT expression.
Therefore, although the \rulenameref{Store} rule may have multiple derivations in general,
there is a single derivation in this case.
In particular, it also implies that:
\[ \moWrite{\symmo'}{\bvconst{64}{\addr}}{\bvconst{8}{7}} = (\bvval{\addr}{64}, \bvval{2}{32}, \arraystore{\smtarray}{(\bvextract_{32}(\bvsub(\bvconst{64}{\addr}, \bvconst{64}{\addr})))}{\bvconst{8}{7}}) \]

On the other side, the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {\location_7}
    {\{ ..., \nameid{gep1} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[\symmo'_{opt}]}
    {n < \bvconst{32}{2}}
\]
where:
\[ \symmo'_{opt} \triangleq (\bvval{\addr}{64}, \bvval{2}{32}, \smtarray'_{opt}), \ \smtarray'_{opt} \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
Now, we have to prove that the subtree of $s$ is safe.
Note that $s$ is not an error state,
since $\evalexprty{\nameid{gep1}}{\symlocalstore}{\bvsort{64}} = \bvconst{64}{\addr}$ for every model $m$.
To prove that $s' \equiv s'_{opt}$, it suffices to prove the equivalence of their memory and path constraints.
As for the memory, it suffices to prove that:
\[ \arraystore{\smtarray}{(\bvextract_{32}(\bvconst{64}{\addr} - \bvconst{64}{\addr}))}{\bvconst{8}{7}} \equiv \smtarray'_{opt} \]
For this, we define a lemma that can be applied in general when storing a single byte (\ie \bvsort{8}):
% TODO: introduce all variables
\begin{lemma}
\label{lemma:smtarray-equiv}
Let $\bvconst{32}{i}$, ..., $\bvconst{32}{(i + n)}$ be subsequent constant SMT expressions,
and assume that $k \equiv \bvconst{32}{i}$ and $v' \equiv v'_{opt}$, then:
\[ \arraystore{\arraystore{\arraystore{a}{\bvconst{32}{i}}{v}[...]}{\bvconst{32}{(i + n)}}{t_n}}{k}{v'} \equiv \arraystore{\arraystore{a}{\bvconst{32}{i}}{v'_{opt}}[...]}{\bvconst{32}{(i + n)}}{t_n} \]
\end{lemma}
This lemma can be applied in our case,
since $\bvextract_{32}(\bvsub(\bvconst{64}{\addr}, \bvconst{64}{\addr})) \equiv \bvconst{32}{0}$ and $\bvconst{8}{7} \equiv \bvconst{8}{7}$.
We define similar lemmas to handle stores of other types (\bvsort{16}, \bvsort{32}, and \bvsort{64}).
As for the path constraints,
note that $\rangecond(\bvconst{64}{\addr}, 1, \symmo) \equiv \true$, so the equivalence follows easily.

\subsubsection{\textit{Example: GetElementPtr.}}
% TODO: explain how to prove that this is not an error state
The symbolic state at~\cref{line:llvm-gep} is:
\[
s \triangleq \symstate
    {\location_{10}}
    {\{ ..., \nameid{idx} \mapsto \bvzext_{64}(n) \}}
    {[]}
    {...}
    {n < \bvconst{32}{2}}
\]
According to the symbolic semantics, the derived symbolic state is:
\[
s' \triangleq \symstate
    {\location_{11}}
    {\{ ..., \nameid{idx} \mapsto \bvzext_{64}(n), \nameid{gep2} \mapsto e \}}
    {[]}
    {...}
    {n < \bvconst{32}{2}}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvzext_{64}(n)), \bvconst{32}{1}))) \]
The symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {\location_{11}}
    {\{ ..., \nameid{idx} \mapsto \bvzext_{64}(n), \nameid{gep2} \mapsto e_{opt} \}}
    {[]}
    {...}
    {n < \bvconst{32}{2}}
\]
where:
\[ e_{opt} \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]
Now, we need to prove that the subtree of $s$ is safe.
To prove that $s$ is not an error state, we will use the following lemma:
% TODO: define overflowcond
% TODO: where $\overflowcond$ computes an SMT formula that encodes the fact that an overflow occured.
\begin{lemma}
Let $\tau$ be a type, $p$ a pointer value of type $\bvsort{\pointerwidth}$, and $\overline{t_i}$ a sequence of SMT expressions.
If $\evalgep(\tau, p, \overline{m[t_i]}) = \tpoison$,
then $m \models \overflowcond(\tau, \overline{t_i})$.
\end{lemma}
Then, based on~\Cref{def:sym-error-state},
it suffices to prove that $n < \bvconst{32}{2} \land \overflowcond(\bvsort{64}, [\bvzext_{64}(n)])$ is unsatisfiable.
In our case, it unfolds to the following constraint:
\[
\begin{array}{ll}
    n < \bvconst{32}{2} \ \land \ \big(&(\bvzext_{64}(n) > \bvconst{64}{4294967295}) \ \lor \\
                         &(\bvmul_{64}(\bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n))), \bvconst{64}{1}) > \bvconst{64}{4294967295})\big)
\end{array}
\]
which is indeed unsatisfiable.
To prove that $s' \equiv s'_{opt}$,
it suffices to prove that their stores are equivalent, which holds since $e \equiv e_{opt}$.

\subsubsection{\textit{Example: Load.}}
% TODO: remind that the repr is non-opt now
The symbolic state at~\cref{line:llvm-load} is:
\[
s \triangleq \symstate
    {\location_{11}}
    {\{ ..., \nameid{gep2} \mapsto e \}}
    {[]}
    {[\symmo]}
    {n < \bvconst{32}{2}}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]
\[ \symmo \triangleq (\bvval{\addr}{64}, \bvval{2}{32}, \smtarray), \ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]

On one side, according to the symbolic semantics,
if $s'$ is derived from $s$ then there exist a model $m$ and a memory object $\symmo' \triangleq (\addr', \size', \smtarray')$ such that
$m \models \pc$, $\symmo' \in \symmemory$, and $\symisinbounds{e}{\bvsort{8}}{\symmo'}{m}$, and then:
% TODO: should add 0_{32}?
\[
s' \triangleq \symstate
    {\location_{12}}
    {\{ ..., \nameid{gep2} \mapsto e, \nameid{v} \mapsto \arrayselect{\smtarray'}{\bvextract_{32}(\bvsub_{64}(e, \bvconst{64}{\addr}))} \}}
    {[]}
    {[\symmo]}
    {n < \bvconst{32}{2} \land \rangecond(e, 1, \symmo')}
\]
Before dereferencing $e$, the \SE engine checks if $e$ may point to other memory objects,
by checking the satisfiability of $n < \bvconst{32}{2} \land \neg \rangecond(e, 1, \symmo)$.
Here, this constraint is unsatisfiable,
which means that $e$ points only to $\symmo$.
In particular, it must hold that $\symmo' = \symmo$ (and $\smtarray' = \smtarray$).

One the other side, the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {\location_{12}}
    {\{ ..., \nameid{gep2} \mapsto e, \nameid{v} \mapsto \arrayselect{\smtarray}{\bvextract_{32}(\bvsub_{64}(e, \bvconst{64}{\addr}))} \}}
    {[]}
    {[\symmo]}
    {n < \bvconst{32}{2}}
\]
Now, we have to prove that the subtree of $s$ is safe.
We already know that $n < \bvconst{32}{2} \land \neg \rangecond(e, 1, \symmo)$ is unsatisfiable,
so by~\Cref{def:sym-error-state}, $s$ is not an error state.
To prove that $s' \equiv s'_{opt}$, it suffices to prove the equivalence of their path constraints.
Since $n < \bvconst{32}{2} \land \neg \rangecond(e, 1, \symmo)$ is unsatisfiable,
this implies that $n < \bvconst{32}{2} \land \rangecond(e, 1, \symmo) \equiv n < \bvconst{32}{2}$.
