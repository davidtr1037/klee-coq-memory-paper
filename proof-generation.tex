\section{Proof Generation}
\label{sec:proof-generation}

This section will be a bit KLEE-specific,
but we can claim that our approach can be adapted for other implementations as well.

\subsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects.
A memory object is associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequece of SMT store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

\subsection{Proving Safety of Steps}
% TODO use \bvconst instead of regular constants?

% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for malloc
% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% example for free
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

\subsubsection{Example: Malloc}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ \}}
    {[]}
    {(\_, [])}
    {\true}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \addr_0 \}}
    {[]}
    {(\_, [(\addr_0, 10, \arrayconst{\arrayinitvalue})])}
    {\true}
\]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ \nameid{\_} \mapsto \addr_0 \}}
    {[]}
    {(\_, [(\addr_0, 10, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue})])}
    {\true}
\]

\subsubsection{Example: GetElementPtr}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvadd_{64}(\addr_0, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvconst{64}{0}), \bvconst{32}{1}))) \}}
    {[]}
    {...}
    {n < 2}
\]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \addr_0 \}}
    {[]}
    {...}
    {n < 2}
\]

\subsubsection{Example: Store}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray_0)])}
    {n < 2}
\]
where:
\[\smtarray_0 \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray_1)])}
    {n < 2 \land \rangecond(\addr_0, 1, \symmo)}
\]
where:
\[ \smtarray_1 \triangleq \arraystore{\smtarray_0}{\bvconst{64}{(\addr_0 + 1)} - \addr_0}{\bvconst{8}{7}} \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray_1^{'})])}
    {n < 2}
\]
where:
\[ \smtarray_1^{'} \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: note the change at offset 1

\subsubsection{Example: Load}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray)])}
    % TODO: use bvadd?
    {n < 2 \land \rangecond(\addr_0 + n, 1, \symmo)}
\]
where:
% TODO: should add 0_{32}?
\[ e \triangleq \bvextract_{32}(\bvsub(\bvadd_{64}(\addr_0, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), \addr_0)) \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr_0, 10, \smtarray)])}
    {n < 2}
\]
where:
\[ e \triangleq \bvextract_{32}(\bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\begin{figure}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\caption{A simple \llvm IR program.}
\label{figure:example-llvm}
\end{figure}

\subsection{Optimizations}
\begin{itemize}
    \item reusing terms (memory, ...)
    \item specialized lemmas (interface lemmas)
    \item ...
\end{itemize}
