\section{Proof Generation}
\label{sec:proof-generation}

\Cref{theorem:safety-via-et} implies that if there exists an execution tree that satisfies the premise of the theorem,
then we can obtain a safety proof for the input program.
In this section, we show how to compute such execution trees and how to prove their desired properties.
% TODO: mention the section?
Our approach is based on~\cite{klee-rocq}, which works as an instrumentation of the \SE engine, and we extend it to support memory operations.
Our approach generates a \coq proof that consists of a pre-defined section and an auto-generated section.
The pre-defined section is written manually and it contains the various definitions that were given in~\Cref{sec:background,sec:core}:
concrete semantics, symbolic semantics, etc.
The auto-generated section is generated by the \SE engine during the analysis of the given program,
and it contains definitions that are specific to that program:
module definitions, symbolic states, execution tree, etc.

In this section, we present our approach using \klee as the underlying \SE engine.
However, we note that our approach can be adapted to other \SE implementations as well.
Before diving into the details,
we give some background about the memory modeling in \klee.

\subsection{Memory Modeling in \klee}
%In this section,
%we give some background about the memory modeling in \klee.

% TODO: unique interval?
In \klee, the memory of a symbolic state is represented as a linear address space containing memory objects.
A memory object is associated with a concrete base address and a concrete size.
To encode the contents of a memory object,
\klee uses two representations: \emph{optimized} and \emph{non-optimized}.
If all the stores to a given memory object were performed with a concrete offset,
then \klee uses the optimized representation where the contents are encoded as a mapping between constant offsets and symbolic values.
When there is a store with a symbolic offset,
\klee switches to the non-optimized representation,
by translating the optimized representation into an SMT array, \ie a sequence of store expressions.
Once this happens, the representation cannot be switched back to the optimized one.

% TODO: needed here?
%The SMT arrays that are used to encode the contents of a memory object has the sort: ...
%Therefore, when a memory object is accessed,
%the SMT expression corresponding to the offset is truncated to an SMT expression of sort $\smtsort{32}$.

For example, after executing~\cref{line:example-store} from~\Cref{figure:example-llvm},
the contents of the memory object allocated at~\cref{line:example-malloc} are encoded using the optimized representation as follows:
\[ \{ 0 \mapsto \bvconst{8}{7}, 1 \mapsto \bvconst{8}{0} \} \]
If we were to execute the instruction \code{p[n] = 1} afterwards,
then we would switch to the non-optimized representation resulting in the following encoding:
\[ \arraystore{\arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\bvconst{8}{0}}}{n}{\bvconst{8}{1}} \]

\begin{figure}
\begin{minipage}[t]{0.60\columnwidth}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=llvm,mathescape=true,breaklines=false]{code/example.simple.ll}
\end{minipage}
\begin{minipage}[t]{0.38\columnwidth}
\lstinputlisting[basicstyle=\scriptsize\ttfamily,language=c,mathescape=true,breaklines=false]{code/example.simple.c}
\end{minipage}
\caption{A simple \llvm IR program (left) and its source code (right).}
\label{figure:example-llvm}
\end{figure}

\subsection{Module Translation}
...

\subsection{Symbolic State Translation}
The symbolic states generated by the \SE engine are translated to definitions in \coq.
The translation of a memory object \coq works as follows.
In the case of an optimized representation,
the internal mapping $\{0 \mapsto e_0, 1 \mapsto e_1, \ldots\}$ is translated to a sequence of store expressions:
\[ \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{e_0}}{\bvconst{32}{1}}{e_1} \ldots \]
In the case of a non-optimized representation,
we directly translate the sequence of store expressions used internally to a sequence of store expressions in \coq.
The memory is then translated into a list of memory objects in \coq.
The translation of other components is done similarly to~\cite{klee-rocq}.

\subsection{Proving Execution Tree Safety using Interface Lemmas}
% TODO: explain how we prove the the ET is safe
% TODO: explain the concept of interface lemmas (why needed? ...)
% TODO: use \bvconst instead of regular constants?
% TODO: in this section: iptr = i64 / iidx = i32
% TODO: an example of ET def?

% proving safety of steps: load, store, malloc/alloca, free
% handling different encodings of SMT arrays (KLEE/Coq)

% example for gep (concrete / symbolic)
% example for load (concrete / symbolic)
% example for store (concrete / symbolic)
% use an example with load/store of i8?
% explain the UNSAT query in gep
% explain the UNSAT query in symbolic load/store

First, we generate the definition of the execution tree in a bottom-up manner.
Then, we have to prove that the execution tree satisfies the $\safeet$ relation.
We generate this proof in a bottom-up manner as well, showing that each subtree satisfies the required properties.
The proof of each subtree corresponds to a single instruction that was executed during the analysis.
Generating an explicit proof from scratch for each subtree is expensive in terms of proof generation,
and it also make the proof checking inefficient,
as such a proof requires expensive \coq tactics such as: \textit{inversion}, \textit{subst}, \etc
Instead, we adapt the approach proposed in~\cite{klee-rocq},
and create for each instruction type a generic lemma that can be used to infer execution tree safety.
We call these lemmas \emph{interface} lemmas,
as they help to create an effective interaction between the pre-defined and auto-generated sections of the proof.
By using such interface lemmas,
we accelerate both proof generation and proof checking,
since we create smaller proofs which mainly rely on simple tactics such as \textit{apply} and \textit{reflexivity}.

Now, we will show how to define such interface lemmas,
and how to apply them in the context of the example from~\Cref{figure:example-llvm}.
In this section, we will focus on memory-related instructions.

\subsubsection{Example: Malloc}
% TODO: explain how to prove that this is not an error state
% TODO: discuss the case where the size is symbolic
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ \}}
    {[]}
    {[]}
    {\true}
\]
In general, the \rulenameref{Malloc} rule may result in multiple derivations,
but in this case, the size argument of \textit{malloc} is evaluated to a constant SMT expression,
so the only derived symbolic state is:
\[
s' \triangleq \symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\bvval{\addr}{64}, \bvval{2}{32}, \arrayconst{\arrayinitvalue})]}
    {\true}
\]
where $b \triangleq \nfa{\symmemory}$.
At this point, the \SE engine uses an optimized representation for the allocated memory object, as no stores have been performed yet,
so the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {...}
    {\{ \nameid{\_} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\bvval{\addr}{64}, \bvval{2}{32}, \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue})]}
    {\true}
\]
% TODO: show that $s$ is not an error state
Now, to show that the subtree of $s$ is safe, we need to show that $s' \equiv s'_{opt}$.
The SMT arrays in the two symbolic states are encoded differently,
but they are actually equivalent, since the additional store expressions contain the same value $v$ as in $\arrayconst{v}$.

To handle such cases in general, we define an interface lemma for \textit{malloc}, which is stated as~\Cref{lemma:interface-malloc}.
In this case, we can apply~\Cref{lemma:interface-malloc} with $n$ as 2, $\symmo$ as ..., and $t$ as the subtree of $s'_{opt}$.
% TODO: show why the preconditions hold?

Note that this lemma assumes that the size argument of \textit{malloc} is evaluated to a concrete SMT expression.
If that is not the case,
then the \SE engine concretizes the symbolic expression,
and then the analysis may be incomplete and a safety proof may not be derived.
There exist extensions of \klee that support symbolic-size allocations (\eg \cite{symsize-model}),
however, it is not the focus of this work.

\begin{lemma}
\label{lemma:interface-malloc}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{64}}~\intrinsicfunc{malloc}(e)}$},
and let $b \triangleq \nfa{\symmemory}$.
If there exist $n$, $\symmo$, and $t$ such that:
\begin{enumerate}
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}} \equiv \bvval{n}{64} \land n < max\_signed_{\bvsort{32}}$
    \item $\symmo \equiv (\bvval{b}{64}, \bvval{n}{32}, \arrayconst{\arrayinitvalue})$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \bvconst{64}{b}]}{\symstack}{\symmemory \mathbin{++} [\symmo]}{\pc}$
    \item $\safeet(t)$
\end{enumerate}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: GetElementPtr}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
According to the symbolic semantics, the derived symbolic state is:
\[
s' \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvconst{64}{0}), \bvconst{32}{1}))) \}}
    {[]}
    {...}
    {n < 2}
\]
The symbolic state computed by the \SE engine:
\[
s'_{opt} \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {...}
    {n < 2}
\]
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}$}.
If there exist $\symlocalstore'_{opt}$ and $t$ such that:
\begin{itemize}
    \item $\evalexprty{e_i}{\symlocalstore}{\tau_i} = k_i$
    \item $\unsat(\overflowcond(\tau, \overline{k_i}))$
    \item \textup{$\symlocalstore'_{opt} \equiv \symlocalstore[x \mapsto \evalexprty{\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}}{\symlocalstore}{\tau^{*}}]$}
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

\subsubsection{Example: Store}
% TODO: explain how to prove that this is not an error state
% TODO: show the lemma for array equivalence
% TODO: the type is i8, so we add a single store expression
% TODO: fix the index expression
The initial symbolic state:
\[
s \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\bvval{\addr}{64}, \bvval{2}{32}, \smtarray)]}
    {n < 2}
\]
where:
\[\smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\arrayinitvalue}}{\bvconst{32}{1}}{\arrayinitvalue} \]

% TODO: note that $m[\evalexprty{\nameid{arrayidx}}{\symlocalstore}{\pointertypeof{\bvsort{64}}}] = \bvconst{64}{\addr}$?
On one side, according to the symbolic semantics,
if $s'$ is derived from $s$ then there exist an SMT model $m$ and a memory object $\symmo$ such that
$m \models \pc$, $\symmo \in \symmemory$, and $\isinbounds{\bvconst{64}{\addr}}{1}{\symmo}$, and then:
\[
s' \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[\writemo(\symmo, \bvconst{64}{\addr}, \bvconst{8}{7})]}
    {n < 2 \land \rangecond(\bvconst{64}{\addr}, 1, \symmo))}
\]
We assume that $\symmemory$ is well-formed, which implies that address intervals of memory objects do not overlap,
so if $\symmo \in \symmemory$, then $\symmo$ must be equal to $(\bvval{\addr}{64}, \bvval{2}{32}, \smtarray)$,
since $\bvconst{64}{\addr}$ is a constant SMT expression.
Therefore, although the \rulenameref{Store} rule may have multiple derivations in general,
$s'$ is the only possible derivation here.

On the other side, the symbolic state computed by the \SE engine is:
\[
s'_{opt} \triangleq \symstate
    {...}
    {\{ ..., \nameid{arrayidx} \mapsto \bvconst{64}{\addr} \}}
    {[]}
    {[(\bvval{\addr}{64}, \bvval{2}{32}, \smtarray')]}
    {n < 2}
\]
where:
\[ \smtarray' \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
% TODO: note the change at offset 1

% TODO: show the store_i8 lemma?
Now, we have to show that the subtree of $s$ is safe.
Note that $s$ is not an error state,
since $m[\evalexprty{...}{\symlocalstore}{\pointertypeof{\bvsort{64}}}] = \bvconst{64}{\addr}$ for every SMT model $m$.
To prove that $s' \equiv s'_{opt}$, it remains to prove the equivalence of their memory and path constraints.
As for the memory,
note that $(\bvextract_{32}(\bvconst{64}{\addr} - \bvconst{64}{\addr})) \equiv \bvconst{32}{0}$,
so $\arraystore{\smtarray}{(\bvextract_{32}(\bvconst{64}{\addr} - \bvconst{64}{\addr}))}{\bvconst{8}{7}} \equiv \smtarray'$.
As for the path constraints,
note that $\rangecond(\bvconst{64}{\addr}, 1, \symmo) \equiv \true$, so the equivalence follows easily.

% this intuition is packed/formulated in the following interface lemma
% we generalize the proof sketch / intuition above to an interface lemma...
The proof above is generalized into an interface lemma for \textit{store}, which is stated as~\Cref{lemma:interface-store}.
%The interface lemma for \textit{store} is given as~\Cref{lemma:interface-store}.
\begin{lemma}
\label{lemma:interface-store}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2}$}.
If there exist $\symmo$ and $t$ such that:
\begin{itemize}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e_1}{\symlocalstore}{\tau} = v$
    \item $\evalexprty{e_2}{\symlocalstore}{\bvsort{64}^{*}} = \bvconst{64}{p}$
    \item $\isinbounds{\bvval{p}{64}}{|\tau|}{\symmo}$
    \item $\symmo'_{opt} \equiv \writemo(\symmo, \bvconst{64}{p}, v)$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\replace(\symmemory, \symmo'_{opt})}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}
To show that the subtree of $s$ is safe,
we can apply~\Cref{lemma:interface-store} with $\symmo$ as $(\bvval{\addr}{64}, \bvval{2}{32}, \smtarray)$.

\subsubsection{Example: GetElementPtr (2)}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ... \}}
    {[]}
    {...}
    {n < 2}
\]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvmul_{32}(\bvextract_{32}(\bvzext_{64}(n)), \bvconst{32}{1}))) \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto e \}}
    {[]}
    {...}
    {n < 2}
\]
where:
\[ e \triangleq \bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]

\subsubsection{Example: Load}
% TODO: explain how to prove that this is not an error state
The initial symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots \}}
    {[]}
    {(\_, [(\addr, 2, \smtarray)])}
    {n < 2}
\]
where:
\[ \smtarray \triangleq \arraystore{\arraystore{\arrayconst{\arrayinitvalue}}{\bvconst{32}{0}}{\bvconst{8}{7}}}{\bvconst{32}{1}}{\arrayinitvalue} \]
The derived symbolic state:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 2, \smtarray)])}
    {n < 2 \land \rangecond(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), 1, \symmo)}
\]
where:
% TODO: should add 0_{32}?
\[ e \triangleq \bvextract_{32}(\bvsub_{64}(\bvadd_{64}(\bvconst{64}{\addr}, \bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))), \bvconst{64}{\addr})) \]
\[ \symmo \in ... \]
The symbolic state computed by the \SE engine:
\[
\symstate
    {...}
    {\{ ..., \nameid{arrayidx2} \mapsto \sdots, \nameid{\%0} \mapsto \arrayselect{\smtarray}{e} \}}
    {[]}
    {(\_, [(\addr, 2, \smtarray)])}
    {n < 2}
\]
where:
\[ e \triangleq \bvextract_{32}(\bvzext_{64}(\bvextract_{32}(\bvzext_{64}(n)))) \]
\begin{lemma}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$,
where \textup{$\instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e}$}.
If there exist $\symmo$ and $t$ such that:
\begin{itemize}
    \item $\symmemory$ is well-formed
    \item $\symmo \in \symmemory$
    \item $\evalexprty{e}{\symlocalstore}{\bvsort{64}^{*}} = p$
    \item $\unsat(\pc \land \rangecond(p, |\tau|, \symmo))$
    \item $\symlocalstore'_{opt} \equiv \symlocalstore[x \mapsto \readmo(\symmo, p, |\tau|)]$
    \item $t.\attrstate = \symstate{\nextinstr{\location}}{\symlocalstore'_{opt}}{\symstack}{\symmemory}{\pc}$
    \item $\safeet(t)$
\end{itemize}
then $\safeet(\tree(s, [t]))$.
\end{lemma}

% similarly to ..., we reuse terms to accelerate the ...
% here, we extend this approach to handle ..
% more spec., ...
% what about interface lemmas?
