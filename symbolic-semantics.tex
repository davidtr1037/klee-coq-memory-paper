\subsection{Symbolic Memory Model}
% TODO: some background about SE
% TODO: symbolic state

% TODO: allocator
% TODO: explain why deterministic
% TODO: requires the same allocator in KLEE
% TODO: hard-code the array sort?

A \emph{symbolic memory object} is defined as a tuple:
\[ (\addr, \size, \smtarray) \in \Vals^{\pointertype} \times \Vals^{\indextype} \times \arraysort{\smtsort{8}}{\smtsort{32}} \]
which is similar to the definition of a concrete memory object,
but now the contents are represented using an SMT array, \ie a store expression.
The symbolic heap and the symbolic allocator are defined similarly to their concrete counterparts.

\begin{definition}
\label{def:symbolic-state}
A \emph{symbolic state} is a tuple $\symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$.
...
\end{definition}

\subsection{Symbolic Semantics}
\label{sec:symbolic-semantics}
\begin{itemize}
    \item instructions
    \item GEP
\end{itemize}

\begin{figure}[t]
\[
\begin{array}{c}
\ruledefsmall{Assign}{
    \instrat{\location} = \codequote{x ~\texttt{=}~ e} \quad
    e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\tau} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \evalexprty{e}{\symlocalstore}{\tau}]}{\symstack}{\symmemory}{\pc}
}
\\[1.2em]
\ruledefsmall{Branch-True}{
    \instrat{\location} = \codequote{\tbr ~ e ~ b_1 ~ b_2}
    \quad
    \welldef{\location\triangleright b_i \neq \bot}
    \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\location\triangleright b_1}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \evalexprty{e}{\symlocalstore}{\bvsort1}}
}
\\[1.2em]
\ruledefsmall{Branch-False}{
    \instrat{\location} = \codequote{\tbr ~ e ~ b_1 ~ b_2}
    \quad
    \welldef{\location\triangleright b_i \neq \bot}
    \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\location\triangleright b_2}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \lnot\evalexprty{e}{\symlocalstore}{\bvsort1}}
}
\\[1.2em]
\ruledefsmall{Make-Symbolic}{
  \begin{array}{@{}c@{}}
    \instrat{\location} = \codequote{x ~\texttt{=}~ \tcall ~ \intrinsicfunc{make\_symbolic}()}
    \\
    \alpha \not \in \freevars(\symlocalstore) \cup \freevars(\symstack)
  \end{array}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \alpha]}{\symstack}{\symmemory}{\pc}
}
\\[1.2em]
\ruledefsmall{Assume}{
    \instrat{\location} = \codequote{\tcall ~ \intrinsicfunc{assume}(e)}
    \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \evalexprty{e}{\symlocalstore}{\bvsort1}}
}
\\[1em]
\ruledefsmall{Malloc}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\pointertype}~\intrinsicfunc{malloc}(e)} \quad
  \evalexprty{e}{\symlocalstore}{\indextype} = n \quad
  \allocate(\symmemory, n) = (\symmemory', p) \quad
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto p]}{\symstack}{\symmemory'}{\pc}
}
\\[1em]
\ruledefsmall{Free}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{free}(e)} \quad
  \evalexprty{e}{\symlocalstore}{\pointertype} = p \quad
  m \models \pc \quad
  \mo \in \symmemory \quad
  \symisbaseaddr{p}{mo}{m} \quad
  \mathit{remove}(\symmemory, \mo) = \symmemory'
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory'}{\pc \land \baseaddrcond(p, \mo)}
}
\\[1em]
\ruledefsmall{Load}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\symlocalstore}{\pointertype} = p \quad
  m \models \pc \quad
  \mo \in \symmemory \quad
  \symisinbounds{p}{|\tau|}{mo}{m} \quad
  \readmo(\mo, p, |\tau|) = v \quad
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto v]}{\symstack}{\symmemory}{\pc \land \rangecond(p, |\tau|, \mo)}
}
\\[1em]
\ruledefsmall{Store}{
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\symlocalstore}{\tau} = v \quad
  \evalexprty{e_2}{\symlocalstore}{\pointertype} = p \quad
  m \models \pc \quad
  \mo \in \symmemory \quad
  \symisinbounds{p}{|\tau|}{mo}{m} \quad
  \writemo(\mo, p, v) = \mo' \quad
  \replace(\symmemory, \mo') = \symmemory'
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory'}{\pc \land \rangecond(p, |\tau|, \mo)}
}
\\[1em]
\ruledefsmall{GetElementPtr}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}} \quad
  |\overline{(\tau_i, e_i)}| > 0 \quad
  \evalexprty{e}{\symlocalstore}{\pointertypeof{\tau}} = p \quad
  \evalexprty{e_i}{\symlocalstore}{\tau_i} = j_i \quad
  \evalgep(\tau, p, j_0, [...]) = v
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto v]}{\symstack}{\symmemory}{\pc}
}
\end{array}
\]
\caption{Symbolic operational small-step semantics of LLVM IR.}
\label{fig:symbolic-semantics}
\end{figure}

\subsubsection{\textit{Malloc.}}
% TODO: use the same pre-defined value
The symbolic semantics of \textit{malloc} mirror the concrete semantics,
differing only in the handling of content initialization.
The SMT array of the newly allocated memory object is set to a constant array $\arrayconst{v}$,
which maps all the indices to a pre-defined SMT expression $v$.

\subsubsection{\textit{Free.}}
% TODO: assume that the type of p is iptr?
% TODO: use $\symmemory$ instead of $h$?
When deallocating a pointer $p$,
recall that $p$ is an SMT expression which is not necessarily a constant SMT expression.
Therefore, we check if there exists an SMT model $m$ and a memory object $(\addr, \size, \arrayvalue)$ in the heap $h$ such that
$m$ satisfies that path constraints $\pc$ and $m[p]$ points to $\addr$.
If that is the case,
then we remove that memory object from the heap $h$,
and extend $\pc$ with the condition $\baseaddrcond(p, \mo)$, which constraints $p$ to $\addr$.
Otherwise, the result is undefined-behavior.
Note that this rule might have multiple derivations, since $p$ may be concretized to different base addresses depending on the SMT model.

\subsubsection{\textit{Load.}}
% TODO: what happens if p is undef/poison?
% TODO: mentions the assumptions about n?
When reading $n$ bytes from a pointer $p$,
we check if there exists an SMT model $m$ and a memory object $\mo$ in the heap $h$ such that
$m$ satisfies that path constraints $\pc$ and $m[p + n]$ points to the address interval of $\mo$.
If that is not the case, then the result is undfined-behavior.
Otherwise, we use the \textit{read} procedure to obtain the accessed value.
This procedure reads the corresponding sequence of $n$ stored SMT expressions (of sort $\smtsort{8}$),
and then translates them to a \textit{concat} expression of the appropriate sort.
% TODO: example?

\subsubsection{\textit{Store.}}
% TODO: what happens if p/v is undef/poison?
When writing an expression $e$ to a pointer $p$,
we check if there exists an SMT model $m$ and a memory object $\mo$ in the heap $h$ such that
$m$ satisfies that path constraints $\pc$ and $m[p + n]$ points to the address interval of $\mo$.
If that is not the case, then the result is undfined-behavior.
Otherwise, we use the \textit{write} procedure to store the expression $e$.
This procedure serializes the expression $e$ into a sequence of SMT expressions (of sort $\smtsort{8}$)
and extends the SMT array $\smtarray$ with additional store expressions accordingly.
% TODO: example?

\subsubsection{\textit{GetElementPtr.}}
The symbolic semantics of $\tgep$, given in~\Cref{alg:symbolic-gep},
is similar to the concrete semantics, but uses SMT expressions for the offset and address calculations.
While the concrete version may return $\tundef$ or $\tpoison$,
the symbolic version always returns an SMT expression,
since the symbolic domain does not model $\tundef$ and $\tpoison$.

\begin{algorithm}[t]
\caption{The symbolic semantics of $\tgep$ (without attributes).}
\label{alg:symbolic-gep}
\begin{algorithmic}[1]

\Function{compute-offset}{$\tau, o, \overline{j}$}
    \If {$|\overline{j}| = 0$}
        \State \Return $o$
    \EndIf
    \State $\overline{j} \gets j_1 :: \overline{j'}$
    \If {$\tau = \arraytype{\tau'}$}
        \State $o \gets \bvadd_{32}(o, \bvmul_{32}(\bvsext_{32}(j_1), \bvconst{32}{|\tau'|}))$ \label{line:array-index}
        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
    \EndIf
    \If {$\tau = \structtype{\overline{\tau}}$}
        \State ...
    \EndIf
    \State ...
\EndFunction

\Function{eval-gep}{$\tau, p, j_0, \overline{j}$}
    \State $o \gets \bvmul_{32}(\bvsext_{32}(j_0), \bvconst{32}{|\tau|})$ \label{line:first-index}
    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
    \State \Return $\bvadd_{64}(p, \bvzext_{64}(r))$
\EndFunction

\end{algorithmic}
\end{algorithm}

\begin{definition}
Let $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\memory}{\pc}$ be a symbolic state.
Then $s$ is an \emph{error} state, denoted by $\errorsymstate(c)$, if one of the following holds:
\begin{enumerate}[left=0pt]
    \item $\instrat{\location} = \textup{$\codequote{\tunreachable}$}$
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ op \ \bvsort{w} \ e_1 \ e_2}$}$ and one of the following holds ($t_j \triangleq \evalexprty{e_j}{\symlocalstore}{\bvsort{w}}$):
    \begin{enumerate}[left=-3pt]
        \item \textup{$op \in \{\opcode{udiv}, \opcode{sdiv}, \opcode{urem}, \opcode{srem}\}$} and $\pc \land (t_2 = 0)$ is satisfiable
        \item \textup{$op = \opcode{sdiv}$} and $\pc \land (t_1 = -2^{w - 1}) \land (t_2 = -1)$ is satisfiable
        \item \textup{$op \in \{\opcode{shl}, \opcode{lshr}, \opcode{ashr}\}$} and $\pc \land (t_2 \geq w)$ is satisfiable
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tcall^{\pointertype} \ \intrinsicfunc{malloc}(e)}$}$, and the following holds:
    \begin{enumerate}
        % TODO: use bvconst?
        \item \textup{$\pc \land (t > max\_signed_{\bvsort{32}})$} is satisfiable ($t \triangleq \evalexprty{e}{\symlocalstore}{\tau}$)
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{\tcall~\intrinsicfunc{free}(e)}$}$, and the following holds:
    \begin{enumerate}
        \item $\evalexprty{e}{\symlocalstore}{\tau} = p$
        \item $\syminvalidbaseaddress(\memory, \pc, p)$
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tload^{\tau} \ e}$}$, and the following holds:
    \begin{enumerate}
        \item $\evalexprty{e}{\symlocalstore}{\tau} = p$
        \item $\syminvalidpointer(\memory, \pc, p, |\tau|)$
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{\tstore^{\tau} \ e_1 \ e_2}$}$, and the following holds:
    \begin{enumerate}
        \item $\evalexprty{e_2}{\symlocalstore}{\tau} = p$
        \item $\syminvalidpointer(\memory, \pc, p, |\tau|)$
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tgep~\pointertypeof{\tau} \ e \ \overline{(\tau_i, e_i)}}$}$, and the following holds:
    \begin{enumerate}
        % TODO: needed?
        % \item $|\overline{(\tau_i, e_i)}| > 0$
        \item there exists an SMT model $m$ such that $m[\evalexprty{e}{\localstore}{\pointertypeof{\tau}}] = p$ and $m[\evalexprty{e_i}{\localstore}{\tau_i}] = j_i$
        \item $\evalgep(\tau, p, j_0, [...]) = \tpoison$
    \end{enumerate}
\end{enumerate}
where:
\[
\begin{array}{ll}
    \syminvalidpointer(\memory, \pc, p, n) & \triangleq \exists m. \ \forall \mo \in \memory. \ m \not \models \pc \land \rangecond(p, n, \mo) \\
    \syminvalidbaseaddress(\memory, \pc, p) & \triangleq \exists m. \ \forall \mo \in \memory. \ m \not \models \pc \land \baseaddrcond(p, \mo)
\end{array}
\]
\end{definition}
