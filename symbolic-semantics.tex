\subsection{Symbolic Semantics}
\label{sec:symbolic-semantics}
% TODO: some background about SE
% TODO: symbolic state

% TODO: allocator
% TODO: explain why deterministic
% TODO: requires the same allocator in KLEE
% TODO: hard-code the array sort?

In this section,
we extend the symbolic semantics presented in~\cite{klee-rocq} to support the memory-related instructions given in~\Cref{figure:llvm-syntax}.

\begin{definition}
A symbolic memory object is defined as a tuple:
\[ (\addr, \size, \smtarray) \in \SymMemoryObjects \quad \quad \SymMemoryObjects \triangleq \Vals^{\pointertype} \times \Vals^{\indextype} \times \arraysort{\smtsort{\indexwidth}}{\smtsort{8}} \]
which is similar to the definition of a concrete memory object,
but now the contents are encoded using an SMT array whose values are symbolic bytes, \ie SMT expressions of sort $\bvsort{8}$.
Then, the symbolic memory and the symbolic allocator are defined similarly to their concrete counterparts (\Cref{def:memory}).
\end{definition}

\begin{definition}
\label{def:symbolic-state}
A symbolic state is a tuple $\symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$.
The location $\location \in \Locs$ is defined as before.
The concrete store $\localstore \in \Stores$ is replaced with a symbolic store $\symlocalstore \in \SymStores$,
where $\SymStores \triangleq \Ids \to \Exprs$ and $\Exprs$ is a set of SMT expressions, \ie first-order terms.
The symbolic stack $\symstack \in (\Locs \times \SymStores \times \Ids)^*$ is modified accordingly to hold symbolic stores instead of concrete ones.
The symbolic memory $\symmemory \in (\SymMemoryObjects)^{*}$ is a sequence of symbolic memory objects.
The path constraint $\pc \in \Exprs$ is a formula of sort $\Bool$ which accumulates assumptions along the execution path.
\end{definition}

\Cref{figure:symbolic-semantics} defines the symbolic operational small-step semantics of \llvm IR based on the syntax in~\Cref{figure:llvm-syntax}.
The symbolic evaluation of expressions, \ie $\evalexprty{e}{\symlocalstore}{\tau}$, is defined similarly to the concrete case.
Here, as in~\Cref{sec:background},
we focus on discussing the memory-related instructions.
In some of the rules, we use the following definitions (where $\symmo \triangleq \mobj{\bvval{\addr}{\pointerwidth}}{\bvval{\size}{\indexwidth}}{\smtarray}$):
\[
\begin{array}{ll}
\baseaddrcond(p, \symmo) & \triangleq p = \bvconst{\pointerwidth}{a} \\
\rangecond(p, n, \symmo) & \triangleq p < \bvadd_{\pointerwidth}(p, n) \land p \geq \bvconst{\pointerwidth}{\addr} \land \bvadd_{\pointerwidth}(p, n) < \bvadd_{\pointerwidth}(\bvconst{\pointerwidth}{\addr}, \bvconst{\pointerwidth}{\size})
\end{array}
\]
Informally,
$\baseaddrcond$ denotes that $p$ points to the base address of $\symmo$,
and $\rangecond$ denotes that the interval $[p, p + n)$ is fully contained within the address interval of $\symmo$.
%The rules \rulenameref{Assign}, \rulenameref{Branch-True}, \rulenameref{Branch-False}, \rulenameref{Make-Symbolic}, and \rulenameref{Assume} were discussed in detail in~\cite{klee-rocq},
%so here we extend the discussion to memory-related instructions.

\begin{figure}[t]
\[
\begin{array}{c}
%\ruledefsmall{Assign}{
%  \instrat{\location} = \codequote{x ~\texttt{=}~ e} \quad
%  e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
%  \welldef{\evalexprty{e}{\symlocalstore}{\tau} \neq \bot}
%}
%{
%  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
%  \symstep
%  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \evalexprty{e}{\symlocalstore}{\tau}]}{\symstack}{\symmemory}{\pc}
%}
%\\[1.2em]
%\ruledefsmall{Branch-True}{
%  \instrat{\location} = \codequote{\tbr ~ e ~ b_1 ~ b_2}
%  \quad
%  \welldef{\location\triangleright b_i \neq \bot}
%  \quad
%  \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
%}
%{
%  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
%  \symstep
%  \symstate{\location\triangleright b_1}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \evalexprty{e}{\symlocalstore}{\bvsort1}}
%}
%\\[1.2em]
%\ruledefsmall{Branch-False}{
%  \instrat{\location} = \codequote{\tbr ~ e ~ b_1 ~ b_2}
%  \quad
%  \welldef{\location\triangleright b_i \neq \bot}
%  \quad
%  \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
%}
%{
%  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
%  \symstep
%  \symstate{\location\triangleright b_2}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \lnot\evalexprty{e}{\symlocalstore}{\bvsort1}}
%}
%\\[1.2em]
%\ruledefsmall{Make-Symbolic}{
%  \begin{array}{@{}c@{}}
%    \instrat{\location} = \codequote{x ~\texttt{=}~ \tcall ~ \intrinsicfunc{make\_symbolic}()}
%    \\
%    \alpha \not \in \freevars(\symlocalstore) \cup \freevars(\symstack)
%  \end{array}
%}
%{
%  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
%  \symstep
%  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \alpha]}{\symstack}{\symmemory}{\pc}
%}
%\\[1.2em]
%\ruledefsmall{Assume}{
%  \instrat{\location} = \codequote{\tcall ~ \intrinsicfunc{assume}(\bvsort{1} ~ e)}
%  \quad
%  \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
%}
%{
%  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
%  \symstep
%  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \evalexprty{e}{\symlocalstore}{\bvsort1}}
%}
%\\[1em]
\ruledefsmall{Malloc}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\pointertypeof{\bvsort{8}}}~\intrinsicfunc{malloc}(\bvsort{64} ~ e)} \quad
  \evalexprty{e}{\symlocalstore}{\bvsort{64}} = n \quad
  \symallocate(\symmemory, \bvextract_{\indexwidth}(n)) = (\symmemory', p) \quad
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto p]}{\symstack}{\symmemory'}{\pc}
}
\\[1em]
\ruledefsmall{Free}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{free}(\pointertypeof{\bvsort{8}} ~ e)} \quad
  \evalexprty{e}{\symlocalstore}{\pointertypeof{\bvsort{8}}} = p \quad
  m \models \pc \quad
  \symmo \in \symmemory \quad
  \symisbaseaddr{p}{mo}{m}
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory \setminus \{\symmo\}}{\pc \land \baseaddrcond(p, \symmo)}
}
\\[1em]
\ruledefsmall{Load}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\symlocalstore}{\pointertypeof{\tau}} = p \quad
  m \models \pc \quad
  \symmo \in \symmemory \quad
  \symisinbounds{p}{\tau}{mo}{m}
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \moRead{\symmo}{p}{\tau}]}{\symstack}{\symmemory}{\pc \land \rangecond(p, |\tau|, \symmo)}
}
\\[1em]
\ruledefsmall{Store}{
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\symlocalstore}{\tau} = v \quad
  \evalexprty{e_2}{\symlocalstore}{\pointertypeof{\tau}} = p \quad
  m \models \pc \quad
  \symmo \in \symmemory \quad
  \symisinbounds{p}{\tau}{mo}{m}
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\heapWrite{\symmemory}{\symmo}{p}{v}}{\pc \land \rangecond(p, |\tau|, \symmo)}
}
\\[1em]
\ruledefsmall{GEP}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}} \quad
  |\overline{(\tau_i, e_i)}| > 0 \quad
  \evalexprty{e}{\symlocalstore}{\pointertypeof{\tau}} = p \quad
  \evalexprty{e_i}{\symlocalstore}{\tau_i} = t_i
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \symevalgep(\tau, p, \overline{t_i})]}{\symstack}{\symmemory}{\pc}
}
\end{array}
\]
\caption{Symbolic operational small-step semantics of LLVM IR.}
\label{figure:symbolic-semantics}
\end{figure}

\textbf{\textit{Malloc.}}
The symbolic semantics of \textit{malloc} mirror the concrete semantics,
differing only in the handling of content initialization.
The SMT array of the newly allocated memory object is set to a constant array $\arrayconst{\arrayinitvalue}$.
%which maps all the indices to $\arrayinitvalue$.
\si{mention that we use the same allocator as the concrete case because addresses and sizes are concrete}

\textbf{\textit{Free.}}
% TODO: assume that the type of p is iptr?
When deallocating a pointer $p$,
recall that $p$ is an SMT expression which is not necessarily a constant SMT expression.
Therefore, we check if there exists an SMT model $m$ and a memory object $\symmo \triangleq (\addr, \size, \smtarray)$ in $\symmemory$ such that
$m$ satisfies the path constraints $\pc$ and $m[p]$ points to $\addr$.
If that is the case,
then we remove that memory object from $\symmemory$,
and extend $\pc$ with the condition $\baseaddrcond(p, \symmo)$.
Otherwise, the result is undefined behavior.
Note that this rule might have multiple derivations, since $p$ may point to different memory objects depending on the SMT model.

\textbf{\textit{Load.}}
% TODO: mentions the assumptions about n?
When reading $n$ bytes from a pointer $p$,
we check if there exists an SMT model $m$ and a memory object $\symmo$ in $\symmemory$ such that
$m$ satisfies the path constraints $\pc$ and the first $n$ addresses starting from $m[p]$ are within the address interval of $\symmo$.
If that is not the case, then the result is undefined behavior.
Otherwise, we use the \textit{read} procedure to obtain the accessed value.
This procedure reads the corresponding sequence of $n$ symbolic bytes,
and then translates them to a \textit{concat} expression of the appropriate sort.
At last, we update the path constraints $\varphi$ with the condition $\rangecond(p, n, \symmo)$.
% which makes sure that the first $n$ addresses starting from $p$ are within the address interval of $\symmo$.
% TODO: example?

\textbf{\textit{Store.}}
When writing an expression $e$, whose size is $n$ bytes, to a pointer $p$,
we check if there exists an SMT model $m$ and a memory object $\symmo \triangleq (\addr, \size, \smtarray)$ in $\symmemory$ such that
$m$ satisfies th path constraints $\pc$ and the first $n$ addresses starting from $m[p]$ are within the address interval of $\symmo$.
If that is not the case, then the result is undefined behavior.
Otherwise, we use the \textit{write} procedure to store the expression $e$.
This procedure serializes the expression $e$ into a sequence of symbolic bytes and extends the SMT array $\smtarray$ with additional store expressions accordingly.
At last, we update the path constraints $\varphi$ with the condition $\rangecond(p, n, \symmo)$.
% TODO: example?

\textbf{\textit{GetElementPtr.}}
The symbolic semantics of $\tgep$ is similar to the concrete semantics,
but uses SMT expressions for the offset and address calculations.
While the concrete version may return $\tundef$ or $\tpoison$,
the symbolic version always returns an SMT expression,
since the symbolic domain does not model $\tundef$ and $\tpoison$.

%\begin{algorithm}[t]
%\caption{The symbolic semantics of $\tgep$ (without attributes).}
%\label{alg:symbolic-gep}
%\begin{algorithmic}[1]
%
%\Function{compute-offset}{$\tau, o, \overline{j}$}
%    \If {$|\overline{j}| = 0$}
%        \State \Return $o$
%    \EndIf
%    \State $\overline{j} \gets j_1 :: \overline{j'}$
%    \If {$\tau = \arraytype{\tau'}{n}$}
%        \State $o \gets \bvadd_{32}(o, \bvmul_{32}(\bvsext_{32}(j_1), \bvconst{32}{|\tau'|}))$ \label{line:array-index}
%        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
%    \EndIf
%    \If {$\tau = \structtype{\tau}{n}$}
%        \State ...
%    \EndIf
%    \State ...
%\EndFunction
%
%\Function{eval-gep}{$\tau, p, j_0, \overline{j}$}
%    \State $o \gets \bvmul_{32}(\bvsext_{32}(j_0), \bvconst{32}{|\tau|})$ \label{line:first-index}
%    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
%    \State \Return $\bvadd_{64}(p, \bvzext_{64}(r))$
%\EndFunction
%
%\end{algorithmic}
%\end{algorithm}

Informally,
we say that a symbolic state \emph{represents} a concrete state if the latter can be obtained from the former via concretization using a model that satisfies the path constraints.
This relation will be used to define symbolic error states (\Cref{def:sym-error-state}).
In the following, we extend the definition given in~\cite{klee-rocq} to account for memory.

\begin{definition}
\label{def:over-approx-state}
Let $m$ be a model.
An SMT expression $e$ \emph{represents} a value $v \in \Vals$ via $m$,
denoted by $e \overapproxvia{m} v$, if $\evalmodel{m}{e} = v$.
%A symbolic store $\symlocalstore$ \emph{represents} a concrete store $\localstore$ via $m$,
%denoted by $\symlocalstore \overapproxvia{m} \localstore$,
%if both stores are defined over the same variables and for each such variable $x$, $\mapaccess{\symlocalstore}{x} \overapproxvia{m} \mapaccess{\localstore}{x}$.
%A symbolic frame $\symstackframe{\location}{\symlocalstore}{x}$ \emph{represents} a concrete frame $\stackframe{\location}{\localstore}{x}$ via $m$
%if $\symlocalstore \overapproxvia{m} \localstore$.
%A symbolic stack $\symstack$ \emph{represents} a concrete stack $\stack$ via a model $m$,
%denoted by $\symstack \overapproxvia{m} \stack$,
%if they are of equal size,
%and the frames of $\symstack$ represent the frames of $\stack$ via $m$, pointwise.
A symbolic memory object $(\addr, \size, \smtarray)$ represents a memory object $(\addr, \size, \arrayvalue)$ via $m$ if
$\arrayselect{\smtarray}{\bvconst{\indexwidth}{k}}$ represents $\arrayvalue(\valoftype{k}{\indextype})$ via $m$ for every $k$ in the range of the index type.
A symbolic memory $\symmemory$ represents a memory $\memory$ via $m$, denoted by $\symmemory \overapproxvia{m} \memory$,
if the symbolic memory objects of $\symmemory$ represent the memory objects of $\memory$ via $m$, pointwise.
A symbolic state $s \triangleq \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}$ \emph{represents} a concrete state $c \triangleq \progstate{\location}{\localstore}{\stack}{\memory}$ via $m$,
denoted by $s \overapproxvia{m} c$,
if $\symlocalstore \overapproxvia{m} \localstore$,
$\symstack \overapproxvia{m} \stack$,
$\symmemory \overapproxvia{m} \memory$,
and $\evalmodel{m}{\pc} = \true$.
Furthermore, $s$ \emph{represents} $c$, denoted by $s \overapprox c$,
if $s \overapproxvia{m} c$ for some model $m$.
\end{definition}

\begin{definition}
\label{def:sym-error-state}
A symbolic state $s$ is an error state, denoted by $\errorsymstate(s)$,
if there is a concrete state $c$ such that $s \overapprox c$ and $c$ is an error state.
%if one of the following holds:
%\begin{enumerate}[left=0pt]
%    \item $\instrat{\location} = \textup{$\codequote{\tunreachable}$}$
%    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ op \ \bvsort{w} \ e_1 \ e_2}$}$ and one of the following holds ($t_j \triangleq \evalexprty{e_j}{\symlocalstore}{\bvsort{w}}$):
%    \begin{enumerate}[left=-3pt]
%        \item \textup{$op \in \{\opcode{udiv}, \opcode{sdiv}, \opcode{urem}, \opcode{srem}\}$} and $\pc \land (t_2 = 0)$ is satisfiable
%        \item \textup{$op = \opcode{sdiv}$} and $\pc \land (t_1 = -2^{w - 1}) \land (t_2 = -1)$ is satisfiable
%        \item \textup{$op \in \{\opcode{shl}, \opcode{lshr}, \opcode{ashr}\}$} and $\pc \land (t_2 \geq w)$ is satisfiable
%    \end{enumerate}
%    % TODO: use bvconst?
%    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tcall^{\pointertypeof{\bvsort{8}}} \ \intrinsicfunc{malloc}(\bvsort{64} \ e)}$}$ and
%          \textup{$\sat(\pc \land (t > max\_signed_{\bvsort{32}}))$} ($t \triangleq \evalexprty{e}{\symlocalstore}{\tau}$).
%    \item $\instrat{\location} = \textup{$\codequote{\tcall~\intrinsicfunc{free}(e)}$}$, \textup{$\evalexprty{e}{\symlocalstore}{\pointertype} = p$}, and $\syminvalidbaseaddress(\symmemory, \pc, p)$.
%    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tload^{\tau} \ e}$}$, \textup{$\evalexprty{e}{\symlocalstore}{\pointertype} = p$}, and $\syminvalidpointer(\symmemory, \pc, p, |\tau|)$.
%    \item $\instrat{\location} = \textup{$\codequote{\tstore^{\tau} \ e_1 \ e_2}$}$, \textup{$\evalexprty{e_2}{\symlocalstore}{\pointertype} = p$}, and $\syminvalidpointer(\symmemory, \pc, p, |\tau|)$.
%    % TODO: \item $|\overline{(\tau_i, e_i)}| > 0$
%    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tgep~\pointertypeof{\tau} \ e \ \overline{(\tau_i, e_i)}}$}$, and:
%    \begin{enumerate}
%        \item $\sat(\varphi \land \overflowcond(\tau, \overline{k_i}))$ ($k_i \triangleq \evalexprty{e_i}{\localstore}{\tau_i}$)
%    \end{enumerate}
%\end{enumerate}
%where $\overflowcond(\tau, \overline{k_i})$ constructs a condition that encodes the fact that there are no overlfows when evaluating the $\tgep$ instruction,
%and:
%\[
%\begin{array}{ll}
%    \syminvalidpointer(\symmemory, \pc, p, n) & \triangleq \exists m. \ \forall \symmo \in \symmemory. \ m \not \models \pc \land \rangecond(p, n, \symmo) \\
%    \syminvalidbaseaddress(\symmemory, \pc, p) & \triangleq \exists m. \ \forall \symmo \in \symmemory. \ m \not \models \pc \land \baseaddrcond(p, \symmo)
%\end{array}
%\]
\end{definition}
