\subsection{Symbolic Memory Model}
% TODO: allocator
% TODO: explain why deterministic
% TODO: requires the same allocator in KLEE
% TODO: hard-code the array sort?

A \emph{symbolic memory object} is defined as a tuple:
\[ (\addr, \size, \smtarray) \in \Vals^{\pointertype} \times \Vals^{\indextype} \times \arraysort{\smtsort{8}}{\smtsort{32}} \]
which is similar to the definition of a concrete memory object,
but now the contents are represented using an SMT array, \ie a store expression.
The symbolic heap and the symbolic allocator are defined similarly to their concrete counterparts.

\subsection{Symbolic Semantics}
\label{sec:symbolic-semantics}
\begin{itemize}
    \item instructions
    \item GEP
\end{itemize}

\begin{figure}[t]
\[
\begin{array}{c}
\ruledefsmall{Assign}{
    \instrat{\location} = \codequote{x ~\texttt{=}~ e} \quad
    e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\tau} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \evalexprty{e}{\symlocalstore}{\tau}]}{\symstack}{\symmemory}{\pc}
}
\\[1.2em]
\ruledefsmall{Branch-True}{
    \instrat{\location} = \codequote{\tbr ~ e ~ b_1 ~ b_2}
    \quad
    \welldef{\location\triangleright b_i \neq \bot}
    \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\location\triangleright b_1}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \evalexprty{e}{\symlocalstore}{\bvsort1}}
}
\\[1.2em]
\ruledefsmall{Branch-False}{
    \instrat{\location} = \codequote{\tbr ~ e ~ b_1 ~ b_2}
    \quad
    \welldef{\location\triangleright b_i \neq \bot}
    \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\location\triangleright b_2}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \lnot\evalexprty{e}{\symlocalstore}{\bvsort1}}
}
\\[1.2em]
\ruledefsmall{Make-Symbolic}{
  \begin{array}{@{}c@{}}
    \instrat{\location} = \codequote{x ~\texttt{=}~ \tcall ~ \intrinsicfunc{make\_symbolic}()}
    \\
    \alpha \not \in \freevars(\symlocalstore) \cup \freevars(\symstack)
  \end{array}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto \alpha]}{\symstack}{\symmemory}{\pc}
}
\\[1.2em]
\ruledefsmall{Assume}{
    \instrat{\location} = \codequote{x ~\texttt{=}~ \tcall ~ \intrinsicfunc{assume}(e)}
    \quad
    \welldef{\evalexprty{e}{\symlocalstore}{\bvsort1} \neq \bot}
}
{
    \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
    \symstep
    \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory}{\pc \land \evalexprty{e}{\symlocalstore}{\bvsort1}}
}
\\[1em]
\ruledefsmall{Malloc}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\pointertype}~\intrinsicfunc{malloc}(e)} \quad
  \evalexprty{e}{\symlocalstore}{\indextype} = n \quad
  \mathit{allocate}(\symmemory, n) = (\symmemory', p) \quad
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \symstep
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto p]}{\symstack}{\symmemory'}{\pc}
}
\\[1em]
\ruledefsmall{Free}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{free}(e)} \quad
  \evalexprty{e}{\symlocalstore}{\pointertype} = p \quad
  m \models \pc \quad
  \mo \in \symmemory \quad
  \mathit{is\_base\_address}(p, mo, m) \quad
  \mathit{remove}(\symmemory, \mo) = \symmemory'
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \step
  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory'}{\pc \land \baseaddrcond(p, |\tau|, \mo)}
}
\\[1em]
\ruledefsmall{Load}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\symlocalstore}{\pointertype} = p \quad
  m \models \pc \quad
  \mo \in \symmemory \quad
  \mathit{is\_inbounds}(p, |\tau|, mo, m) \quad
  \mathit{read}(\mo, p, |\tau|) = v \quad
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \step
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto v]}{\symstack}{\symmemory}{\pc \land \rangecond(p, |\tau|, \mo)}
}
\\[1em]
\ruledefsmall{Store}{
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\symlocalstore}{\tau} = v \quad
  \evalexprty{e_2}{\symlocalstore}{\pointertype} = p \quad
  m \models \pc \quad
  \mo \in \symmemory \quad
  \mathit{is\_inbounds}(p, |\tau|, mo, m) \quad
  \mathit{write}(\mo, p, v) = \mo' \quad
  \mathit{replace}(\symmemory, \mo') = \symmemory'
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \step
  \symstate{\nextinstr{\location}}{\symlocalstore}{\symstack}{\symmemory'}{\pc \land \rangecond(p, |\tau|, \mo)}
}
\\[1em]
\ruledefsmall{GetElementPtr}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}} \quad
  |\overline{(\tau_i, e_i)}| > 0 \quad
  \evalexprty{e}{\symlocalstore}{\pointertypeof{\tau}} = p \quad
  \evalexprty{e_i}{\symlocalstore}{\tau_i} = j_i \quad
  \mathit{eval\_gep}(\tau, p, j_0, [...]) = v
}
{
  \symstate{\location}{\symlocalstore}{\symstack}{\symmemory}{\pc}
  \step
  \symstate{\nextinstr{\location}}{\symlocalstore[x \mapsto v]}{\symstack}{\symmemory}{\pc}
}
\end{array}
\]
\caption{Symbolic operational small-step semantics of LLVM IR.}
\label{fig:symbolic-semantics}
\end{figure}
