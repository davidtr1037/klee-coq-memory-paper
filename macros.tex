% !TEX root = paper.tex

\algrenewcommand\algorithmicindent{0.5em}

\newcommand{\showindraft}[1]{#1}

\newcommand{\ignore}[1]{}

\newcommand{\si}[1]{\showindraft{\textcolor{purple}{\textbf{SI:} #1}}}
\newcommand{\dt}[1]{\showindraft{\textcolor{magenta}{\textbf{DT:} #1}}}

\newcommand{\ie}{i.e.,\ }
\newcommand{\eg}{e.g.,\ }
\newcommand{\etal}{et al.}
\newcommand{\etc}{etc.\xspace}
\newcommand{\SE}{SE\xspace}
\newcommand{\klee}{\text{KLEE}\xspace}
\newcommand{\llvm}{\text{LLVM}\xspace}
\newcommand{\coq}{\text{Rocq}\xspace}
\newcommand{\coqc}{\textit{coqc}\xspace}
\newcommand{\ltac}{\textit{Ltac}\xspace}
\newcommand{\vellvm}{\textit{Vellvm}\xspace}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\sdots}{...}

\newcommand\rulenamedef[1]{\small\textsc{(#1)}}
\newcommand\rulenameref[1]{\textsc{#1}}
\newcommand\ruledef[3]{\infer[\rulenamedef{#1}]{#3}{#2}}
\newcommand\ruledefsmall[3]{\infer[\rulenamedef{#1}]{\scalebox{0.9}{$#3$}}{\scalebox{0.8}{$#2$}}}

% Notations for domains
\newcommand\Z{\mathds{Z}}
\newcommand\Bool{\mathit{Bool}}
\newcommand\Types{\mathit{T}}
\newcommand\Vals{\mathit{V}}
\newcommand\Ids{\mathit{Id}}
\newcommand\Locs{\mathit{L}}
\newcommand\Funcs{\mathit{F}}
\newcommand\Stores{\Sigma}
\newcommand\Exprs{\mathit{E}}
\newcommand\Arrays{\mathit{A}}
\newcommand\Heaps{\mathit{H}}

% LLVM
\definecolor{stringcolor}{RGB}{140, 140, 140}
\definecolor{markcolor}{RGB}{183, 28, 28}
\definecolor{codecolor}{RGB}{133,82,21}
\newcommand{\nameid}[1]{\mathit{\textcolor{stringcolor}{#1}}}

\newcommand{\pointertypeof}[1]{\mathit{#1^{*}}}
\newcommand{\arraytype}[1]{\mathit{array[#1]}}
\newcommand{\structtype}[1]{\mathit{struct[#1]}}
\newcommand\tid{\mathit{id}}
\newcommand\tbinop{\mathit{binop}}
\newcommand\tcmpop{\mathit{cmpop}}
\newcommand\toper{\mathit{op}}
\newcommand\tcast{\mathit{cast}}
\newcommand\tinstr{\mathit{instr}}
\newcommand\tfunc{\mathit{func}}
\newcommand\tfuncs{\mathit{funcs}}
\newcommand\tblk{\mathit{blk}}
\newcommand\tmodule{\mathit{module}}
\newcommand\tif{\mathrm{if}}
\newcommand\opcode[1]{\textsf{#1}}
\newcommand\tbr{\opcode{br}}
\newcommand\tcall{\opcode{call}}
\newcommand\tphi{\opcode{phi}}
\newcommand\tret{\opcode{ret}}
\newcommand\tload{\opcode{load}}
\newcommand\tstore{\opcode{store}}
\newcommand\tgep{\opcode{getelementptr}}
\newcommand\tdef{\opcode{def}}
\newcommand\tunreachable{\opcode{unreachable}}
\newcommand\tundef{\mathit{undef}}
\newcommand\tpoison{\mathit{poison}}
\newcommand{\createinst}{\mathit{inst}}

\newcommand{\funcid}{\mathit{id}}
\newcommand{\funcentry}{\mathit{entry}}
\newcommand{\funcargs}{\mathit{args}}

\newcommand{\module}{\Delta}
\newcommand\locsep{{\hspace{1pt}:\hspace{1pt}}}
\newcommand\codequote[2][\textcolor{codecolor}]{{#1{\texttt{`}{#2}\texttt{'}}}}
\newcommand\instrat[1]{\module[{#1}]}
\newcommand\nextinstr[1]{{#1}{+}1}
\newcommand\intrinsicfunc[1]{\textit{#1}}

\newcommand{\mapaccess}[2]{#1(#2)}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand\evalexprty[3]{\sem{#1}^{#3}{#2}}
\newcommand\valoftype[2]{{#1}@{#2}}
\newcommand\bvsort[1]{\textsf{i}{\textsf{#1}}}
\newcommand\bvval[2]{\valoftype{#1}{\bvsort{#2}}}

\newcommand\welldef[1]{{\color{blue!50!white}#1}}

\newcommand{\location}{\ell}
\newcommand{\localstore}{\sigma}
\newcommand{\stack}{\mathit{\kappa}}
\newcommand{\memory}{\mathit{\mu}}
\newcommand{\initstate}{\textit{init}}
\newcommand{\createlocation}[3]{#1\locsep#2\locsep#3}
\newcommand{\stackframe}[3]{\langle{#1},{#2},{#3}\rangle}
\newcommand{\progstate}[4]{\langle{#1},{#2},{#3},{#4}\rangle}
\newcommand{\step}{\rightarrow}
\newcommand{\multistep}{\mathrel{{\step}{}^*\!}}
\newcommand{\errorstate}{\mathit{error}}
\newcommand{\issafe}{\mathit{safe}}
\newcommand{\nsstep}{\stackrel{\raisebox{-3pt}{\scriptsize{\textit{ns}}}}{\rightarrow}}
\newcommand{\multinsstep}{\mathrel{{\nsstep}{}^*\!}}
\newcommand{\issafens}{\mathit{safe_{ns}}}
\newcommand{\pointertype}{\bvsort{ptr}}
\newcommand{\indextype}{\bvsort{idx}}
\newcommand{\addr}{b}
\newcommand{\size}{s}
\newcommand{\arrayvalue}{a}
\newcommand{\mo}{\mathit{mo}}
\newcommand{\heap}{\mathit{h}}
\newcommand{\zeroext}{\mathit{zeroext}}
\newcommand{\signext}{\mathit{signext}}
\newcommand{\convert}{\mathit{convert}}
\newcommand{\isinbounds}{\mathit{is\_inbounds}}
\newcommand{\isbaseaddr}{\mathit{is\_base\_addr}}
\newcommand{\invalidpointer}{\mathit{invalid\_pointer}}
\newcommand{\invalidbaseaddress}{\mathit{invalid\_base\_address}}
\newcommand{\nfa}[1]{\mathit{top}(#1)}
\newcommand{\allocate}{\mathit{allocate}}
\newcommand{\replace}{\mathit{replace}}
\newcommand{\readmo}{\mathit{read}}
\newcommand{\writemo}{\mathit{write}}

% SMT
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\sat}{\mathit{sat}}
\newcommand{\unsat}{\mathit{unsat}}
\newcommand{\transform}{\mathit{transform}}
\newcommand{\subexpr}{\sqsubseteq}
\newcommand{\evalmodel}[2]{#1[#2]}
\newcommand{\smtsort}[1]{\textsf{bv}_{#1}}
\newcommand{\bvconst}[2]{#2_{#1}}
\newcommand{\bvadd}{\textsf{bvadd}}
\newcommand{\bvsub}{\textsf{bvsub}}
\newcommand{\bvmul}{\textsf{bvmul}}
\newcommand{\bvzext}{\textsf{bvzext}}
\newcommand{\bvsext}{\textsf{bvsext}}
\newcommand{\bvextract}{\textsf{bvextract}}
\newcommand{\bvconvert}{\textsf{bvconvert}}
\newcommand{\arraysort}[2]{Array\langle#1,~#2\rangle}
\newcommand{\arrayconst}[1]{K(#1)}
%\newcommand{\arrayselect}[2]{\mathit{select}(#1, #2)}
\newcommand{\arrayselect}[2]{#1[#2]}
%\newcommand{\arraystore}[3]{\mathit{store}(#1, #2, #3)}
\newcommand{\arraystore}[3]{#1[#2 \mapsto #3]}
\newcommand{\arrayinitvalue}{v}

% symbolic semantics
% TODO: fix / make smaller
\makeatletter
\newcommand{\oset}[3][0ex]{\mathrel{\mathop{#3}\limits^{\vbox to#1{\kern-2\ex@\hbox{$#2$}\vss}}}}
\makeatother
\newcommand{\SymStores}{\tilde\Sigma}
\newcommand{\symlocalstore}{\tilde\sigma}
\newcommand{\symstack}{\tilde{\kappa}}
\newcommand{\pc}{\varphi}
\newcommand{\symstate}[5]{\langle{#1},{#2},{#3},{#4},{#5}\rangle}
\newcommand{\errorsymstate}{\mathit{error}}
\newcommand{\symvar}{\alpha}
\newcommand{\overapprox}{\approx}
\newcommand{\overapproxvia}[1]{\approx_{#1}}
\newcommand{\initsymstate}{\widetilde{\textit{init}}}
\newcommand{\symstep}{\oset{\sim}{\rightarrow}}
\newcommand{\symmultistep}{\mathrel{{\symstep}{}^*\!}}
\newcommand{\infeasible}{\mathit{infeasible}}
\newcommand{\symstackframe}[3]{\langle{#1},{#2},{#3}\rangle}
\newcommand{\freevars}{\mathit{FV}}
\newcommand{\smtarray}{\tilde{a}}
\newcommand{\symmo}{\widetilde{\mathit{mo}}}
\newcommand{\symmemory}{\tilde{\mu}}
\newcommand{\baseaddrcond}{\mathit{bc}}
\newcommand{\rangecond}{\mathit{rc}}
\newcommand{\syminvalidpointer}{\mathit{invalid\_pointer}}
\newcommand{\syminvalidbaseaddress}{\mathit{invalid\_base\_address}}

% execution tree
\newcommand{\equivstate}{\equiv}
\newcommand{\safeet}{\textit{safe-et}}
\newcommand{\leaf}{\mathit{leaf}}
\newcommand{\tree}{\mathit{tree}}
\newcommand{\attrstate}{\mathit{state}}
\newcommand{\attrchildren}{\mathit{children}}
\newcommand{\repr}{\mathit{repr}}

% evaluation
\newcommand{\base}{\textit{Base}\xspace}
\newcommand{\proofopt}{\textit{PG}\xspace}
\newcommand{\oom}{\textit{OOM}}
\newcommand{\libtasn}{\textit{libtasn1}\xspace}
\newcommand{\libosip}{\textit{libosip}\xspace}
\newcommand{\coreutils}{\textit{coreutils}\xspace}

\newcommand\x{{\small$\times$}\xspace}

\lstdefinelanguage{coq}{
mathescape=true,
texcl=false,
morekeywords=[1]{Section, Module, End, Require, Import, Export,
  Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
  Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
  Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
  Morphism, Relation, Implicit, Arguments, Unset, Contextual,
  Strict, Prenex, Implicits, Inductive, CoInductive, Record,
  Structure, Canonical, Coercion, Context, Class, Global, Instance,
  Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
  Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
  Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
  Projections, inside, outside, Def},
morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
  match, with, end, as, in, return, let, if, is, then, else, for, of,
  nosimpl, when},
morekeywords=[3]{Type, Prop, Set, true, false, option},
morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
  intro, intros, generalize, rename, pattern, after, destruct,
  induction, using, refine, inversion, injection, rewrite, congr,
  unlock, compute, ring, field, fourier, replace, fold, unfold,
  change, cutrewrite, simpl, have, suff, wlog, suffices, without,
  loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
  symmetry, transitivity, auto, split, subst, left, right, autorewrite},
morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
  assumption, solve, contradiction, discriminate},
morekeywords=[6]{do, last, first, try, idtac, repeat},
morecomment=[s]{(*}{*)},
showstringspaces=false,
tabsize=2,
extendedchars=false,
sensitive=true,
breaklines=false,
captionpos=b,
columns=[l]flexible,
}[keywords,comments,strings]
