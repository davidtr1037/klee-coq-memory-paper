% !TEX root = paper.tex

\algrenewcommand\algorithmicindent{0.5em}

\newcommand{\showindraft}[1]{#1}

\newcommand{\ignore}[1]{}

\newcommand{\si}[1]{\showindraft{\textcolor{purple}{\textbf{SI:} #1}}}
\newcommand{\dt}[1]{\showindraft{\textcolor{magenta}{\textbf{DT:} #1}}}

\newcommand{\ie}{i.e.,\ }
\newcommand{\eg}{e.g.,\ }
\newcommand{\etal}{et al.}
\newcommand{\etc}{etc.\xspace}
\newcommand{\SE}{SE\xspace}
\newcommand{\klee}{\text{KLEE}\xspace}
\newcommand{\llvm}{\text{LLVM}\xspace}
\newcommand{\coq}{\text{Coq}\xspace}
\newcommand{\coqc}{\textit{coqc}\xspace}
\newcommand{\ltac}{\textit{Ltac}\xspace}
\newcommand{\vellvm}{\textit{Vellvm}\xspace}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\sdots}{...}

\newcommand\rulenamedef[1]{\small\textsc{(#1)}}
\newcommand\rulenameref[1]{\textsc{#1}}
\newcommand\ruledef[3]{\infer[\rulenamedef{#1}]{#3}{#2}}
\newcommand\ruledefsmall[3]{\infer[\rulenamedef{#1}]{\scalebox{0.9}{$#3$}}{\scalebox{0.8}{$#2$}}}

% Notations for domains
\newcommand\Nat{\mathds{N}}
\newcommand\Bool{\mathit{Bool}}
\newcommand\Types{\mathit{T}}
\newcommand\Vals{\mathit{V}}
\newcommand\Ids{\mathit{Id}}
\newcommand\Locs{\mathit{L}}
\newcommand\Funcs{\mathit{F}}
\newcommand\Stores{\Sigma}
\newcommand\Exprs{\mathit{E}}

% LLVM
\definecolor{stringcolor}{RGB}{140, 140, 140}
\definecolor{markcolor}{RGB}{183, 28, 28}
\definecolor{codecolor}{RGB}{133,82,21}
\newcommand{\nameid}[1]{\mathit{\textcolor{stringcolor}{#1}}}

\newcommand\tid{\mathit{id}}
\newcommand\toper{\mathit{op}}
\newcommand\tcast{\mathit{cast}}
\newcommand\tinstr{\mathit{instr}}
\newcommand\tfunc{\mathit{func}}
\newcommand\tfuncs{\mathit{funcs}}
\newcommand\tblk{\mathit{blk}}
\newcommand\tif{\mathrm{if}}
\newcommand\opcode[1]{\textsf{#1}}
\newcommand\tbr{\opcode{br}}
\newcommand\tcall{\opcode{call}}
\newcommand\tphi{\opcode{phi}}
\newcommand\tret{\opcode{ret}}
\newcommand\tdef{\opcode{def}}
\newcommand\tunreachable{\opcode{unreachable}}
\newcommand\tundef{\mathit{undef}}
\newcommand\tpoison{\mathit{poison}}
\newcommand{\createinst}{\mathit{inst}}

\newcommand{\funcid}{\mathit{id}}
\newcommand{\funcentry}{\mathit{entry}}
\newcommand{\funcargs}{\mathit{args}}

\newcommand{\module}{\Delta}
\newcommand\locsep{{\hspace{1pt}:\hspace{1pt}}}
\newcommand\codequote[2][\textcolor{codecolor}]{{#1{\texttt{`}{#2}\texttt{'}}}}
\newcommand\instrat[1]{\module[{#1}]}
\newcommand\nextinstr[1]{{#1}{+}1}
\newcommand\intrinsicfunc[1]{\textit{#1}}

\newcommand{\mapaccess}[2]{#1(#2)}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand\evalexprty[3]{\sem{#1}^{#3}{#2}}
\newcommand\valoftype[2]{{#1}@{#2}}
\newcommand\bvsort[1]{\textsf{i}{#1}}
\newcommand\bvval[2]{\valoftype{#1}{\bvsort{#2}}}

\newcommand\welldef[1]{{\color{blue!50!white}#1}}

\newcommand{\location}{\ell}
\newcommand{\localstore}{\sigma}
\newcommand{\stack}{\mathit{\kappa}}
\newcommand{\initstate}{\textit{init}}
\newcommand{\createlocation}[3]{#1\locsep#2\locsep#3}
\newcommand{\stackframe}[3]{\langle{#1},{#2},{#3}\rangle}
% TODO: remove
\newcommand\localstate[2]{\left\langle{#1},{#2}\right\rangle}
\newcommand\progstate[4][]{#1\langle{#2},{#3},{#4}#1\rangle}
\newcommand{\step}{\rightarrow}
\newcommand{\multistep}{\mathrel{{\step}{}^*\!}}
\newcommand{\errorstate}{\mathit{error}}
\newcommand{\issafe}{\mathit{safe}}
\newcommand{\nsstep}{\stackrel{\raisebox{-3pt}{\scriptsize{\textit{ns}}}}{\rightarrow}}
\newcommand{\multinsstep}{\mathrel{{\nsstep}{}^*\!}}
\newcommand{\issafens}{\mathit{safe_{ns}}}

% SMT
\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}
\newcommand{\sat}{\mathit{sat}}
\newcommand{\unsat}{\mathit{unsat}}
\newcommand{\transform}{\mathit{transform}}
\newcommand{\subexpr}{\sqsubseteq}
\newcommand{\evalmodel}[2]{#1[#2]}

% symbolic semantics
\newcommand{\SymStores}{\tilde\Sigma}
\newcommand{\symlocalstore}{\tilde\sigma}
\newcommand{\symstack}{\tilde{\kappa}}
\newcommand{\pc}{\varphi}
\newcommand{\symstate}[4]{\langle{#1},{#2},{#3},{#4}\rangle}
\newcommand{\errorsymstate}{\mathit{error}}
\newcommand{\symvar}{\alpha}
\newcommand{\overapprox}{\approx}
\newcommand{\overapproxvia}[1]{\approx_{#1}}
\newcommand{\initsymstate}{\widetilde{\textit{init}}}
\newcommand{\symstep}{\oset[-.3ex]{\sim}{\rightarrow}}
\newcommand{\symmultistep}{\mathrel{{\symstep}{}^*\!}}
\newcommand{\infeasible}{\mathit{infeasible}}
\newcommand{\symstackframe}[3]{\langle{#1},{#2},{#3}\rangle}
\newcommand{\freevars}{\mathit{FV}}

% execution tree
\newcommand{\equivstate}{\equiv}
\newcommand{\safeet}{\textit{safe-et}}
\newcommand{\leaf}{\mathit{leaf}}
\newcommand{\tree}{\mathit{tree}}
\newcommand{\attrstate}{\mathit{state}}
\newcommand{\attrchildren}{\mathit{children}}
\newcommand{\repr}{\mathit{repr}}

% evaluation
\newcommand{\base}{\textit{Base}\xspace}
\newcommand{\proofopt}{$\textit{PG}_{\textit{opt}}$\xspace}
\newcommand{\oom}{\textit{OOM}}

\newcommand\x{{\small$\times$}\xspace}

\lstdefinelanguage{coq}{
mathescape=true,
texcl=false,
morekeywords=[1]{Section, Module, End, Require, Import, Export,
  Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
  Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
  Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
  Morphism, Relation, Implicit, Arguments, Unset, Contextual,
  Strict, Prenex, Implicits, Inductive, CoInductive, Record,
  Structure, Canonical, Coercion, Context, Class, Global, Instance,
  Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
  Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
  Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
  Projections, inside, outside, Def},
morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
  match, with, end, as, in, return, let, if, is, then, else, for, of,
  nosimpl, when},
morekeywords=[3]{Type, Prop, Set, true, false, option},
morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
  intro, intros, generalize, rename, pattern, after, destruct,
  induction, using, refine, inversion, injection, rewrite, congr,
  unlock, compute, ring, field, fourier, replace, fold, unfold,
  change, cutrewrite, simpl, have, suff, wlog, suffices, without,
  loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
  symmetry, transitivity, auto, split, subst, left, right, autorewrite},
morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
  assumption, solve, contradiction, discriminate},
morekeywords=[6]{do, last, first, try, idtac, repeat},
morecomment=[s]{(*}{*)},
showstringspaces=false,
tabsize=2,
extendedchars=false,
sensitive=true,
breaklines=false,
captionpos=b,
columns=[l]flexible,
}[keywords,comments,strings]
