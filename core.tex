\section{From Symbolic Execution to Formal Safety Proofs}
\label{sec:core}

The framework introduced in~\cite{cpp2025} defines
some fundamental concepts that can be combined
modularly and systematically into safety proofs.
By safety proof, we mean a (machine-checkable) proof
that the input LLVM IR module never encounters an
error state, when evaluated according to the operational semantics defined in \Cref{sec:background}.
This requires reasoning about the set of reachable program states, which is notoriously complex.
Instead of conjuring a proof that directly relates (concrete) reachable states and error states,
and to make better use of the information obtained
from symbolic execution,
\cite{cpp2025} proposed a two-tier approach,
introducing an intermediate \emph{symbolic semantics} layer.

Symbolic execution is founded on the concept of
\emph{symbolic states}---%
program that may contain symbolic values---%
where an interpreter manipulates these states
in a way that is cognate to what a classical interpreter would do.
The \emph{symbolic semantics} formalizes the
expected behavior of such an interpreter.
Presented with an execution trace of a specific implementation, we can then determine whether the
engine followed the rules as dictated by the semantics.
This provides the basis for safety proofs that
only pertain to the symbolic states, effectively
\emph{lifting} the proof from the concrete plane
to the symbolic.

This framework has been previously instantiated as a proof of
concept using a subset of LLVM IR that is 
restricted to integeral values, and without
dynamic memory allocation, arrays, or pointers.
Indeed, adapting the supporting infrastructure to
cover memory access semantic proved to be an arduous one.
Beyond the definitions of the symbolic semantics
corresponding to memory operations,
the development described in this section culminates in a proof of \emph{reachability
completeness} (\Cref{main-thm} below).
Roughly, it claims that the set of reachable
symbolic states sufficiently captures (over-%
approximates) the set of concrete reachable states.

\input{symbolic-semantics.tex}

\subsection{Module Assumptions}

The approach presented in~\cite{klee-rocq} requires the module to satisfy certain assumptions.
More specifically,
it assumes that every operand of an instruction is \emph{safe},
\ie it is neither $\tpoison$ nor does it contain potentially erroneous operations (\eg shift).
In this work,
we further extend these assumptions to operands of memory-related instructions.
In addition,
if the indexed type of a given index in a $\tgep$ instruction is a struct type,
then that index must be a constant and lie within the range of $\bvsort{64}$.

\subsection{Reachability Completeness}
\label{sec:completeness}

Recall from~\Cref{def:over-approx-state} that a concrete state containing a $\tpoison$ value cannot be represented by a symbolic state.
As a result, we cannot prove the reachability completeness of the symbolic semantics w.r.t. the concrete semantics,
since a sequence of steps in the concrete semantics involving $\tpoison$ values cannot be simulated by a sequence of steps in the symbolic semantics.
Instead, we follow the approach from~\cite{klee-rocq},
and prove reachability completeness w.r.t. the non-speculative semantics (Section 3.3 from~\cite{klee-rocq}),
a subset of the concrete semantics restricted to concrete states that do not contain $\tpoison$ values.
Formally, it is defined as follows:
\begin{definition}
A concrete state $c \triangleq \progstate{\location}{\localstore}{\stack}{\memory}$ is \emph{poison-free}
if $\localstore$, $\stack$, and $\memory$ do not contain $\tpoison$ values.
Let $c$ and $c'$ be two concrete states.
We say that there is a \emph{non-speculative} step between $c$ and $c'$, denoted by $c \nsstep c'$,
if $c \step c'$ and both $c$ and $c'$ are poison-free.
\end{definition}
%The non-speculative concrete semantics allows us to relate between symbolic and concrete states,
%which then allows us to prove reachability completeness.
Establishing reachability completeness in this restrictive way is an important step toward proving program safety w.r.t. the concrete semantics.

\begin{definition}
\label{def:issafe-ns-step}
Let $c_0 \triangleq \initstate(\module)$,
then $\module$ is \emph{safe} w.r.t. the non-speculative concrete semantics, denoted by $\issafens(\module)$, if:
\[ \forall c. \ c_{0} \multinsstep c \implies \neg \errorstate(c) \]
(The relation $\multinsstep$ is the reflexive-transitive closure of the relation $\nsstep$.)
\end{definition}

\begin{lemma}
\label{lemma:multi-ns-step-relative-completeness}
Let $c$ and $c'$ be concrete states.
If $\module$ is supported, $c$ is poison-free, no error states can be derived from $c$ using the $\multinsstep$ relation, and $c \multistep c'$,
then $c \multinsstep c'$.
\end{lemma}

\begin{theorem}
\label{theorem:completeness}
Let $c_{0} \triangleq \initstate(\module)$, and let $s_{0} \triangleq \initsymstate(\module)$.
If $\module$ is supported and $c_{0} \multinsstep c$,
then there exists a symbolic state $s$ such that $s_{0} \symmultistep s$ and $s \overapprox c$.
\end{theorem}

\si{write about the additional cases introduced by the extension
to memory operations.}

\subsection{Program Safety via Execution Trees}

An execution tree is a data structure that records the paths explored during the analysis of a given program.
In the following, we rely on its definition from~\cite{klee-rocq} (Section 3.4).
Following the approach of~\cite{klee-rocq},
we show how certain properties of execution trees can be used to prove program safety.
To accommodate memory-related instructions,
we extend the relevant definitions, lemmas, and theorems.

In general, the symbolic states derived by the symbolic semantics may differ from those computed by the \SE engine.
To relate between them, we further extend the definition of \emph{equivalence} for symbolic states.

\begin{definition}
The symbolic stores $\symlocalstore_1$ and $\symlocalstore_2$ are \emph{equivalent}, denoted by $\symlocalstore_1\equiv
\symlocalstore_2$, if they are defined over the same variables,
and for each such variable $x$, $\mapaccess{\symlocalstore_1}{x} \equiv \mapaccess{\symlocalstore_2}{x}$.
The symbolic frames $\symstackframe{\location_1}{\symlocalstore_1}{x_1}$ and $\symstackframe{\location_2}{\symlocalstore_2}{x_2}$ are \emph{equivalent} if
$\location_1 = \location_2$, $\symlocalstore_1 \equiv \symlocalstore_2$, and $x_1 = x_2$.
The symbolic stacks $\symstack_1$ and $\symstack_2$ are \emph{equivalent}, denoted by $\symstack_1 \equiv \symstack_2$,
if their elements are pointwise equivalent.
The symbolic memory objects $(\addr_1, \size_1, \smtarray_1)$ and $(\addr_2, \size_2, \smtarray_2)$ are \emph{equivalent} if
$\addr_1 = \addr_2$, $\size_1 = \size_2$, and $\smtarray_1 \equiv \smtarray_2$.
The symbolic memories $\symmemory_1$ and $\symmemory_2$ are \emph{equivalent}, denoted by $\symmemory_1 \equiv \symmemory_2$,
if their elements are pointwise equivalent.
The symbolic states $s_1 \triangleq \symstate{\location_1}{\symlocalstore_1}{\symstack_1}{\symmemory_1}{\pc_1}$ and $s_2 \triangleq \symstate{\location_2}{\symlocalstore_2}{\symstack_2}{\symmemory_2}{\pc_2}$ are \emph{equivalent},
denoted by $s_1 \equiv s_2$, if $\location_1 = \location_2$, $\symlocalstore_1 \equiv \symlocalstore_2$, $\symstack_1 \equiv \symstack_2$, $\symmemory_1 \equiv \symmemory_2$, and $\pc_1 \equiv \pc_2$.
\end{definition}

The safety property for execution trees is defined below.
This property ensures that there are no error states in the tree, and furthermore,
that every feasible successor $s'$ of any state $s$ occurring in the tree is also represented in the tree as a successor of $s$.
Infeasible states can be ignored, as they do not represent any concrete states.

\begin{definition}
\label{def:safe-et}
The predicate $\safeet$ is defined inductively over execution trees:
\[
\begin{array}{c}
\ruledef{Step}
{
    \neg \errorsymstate(s), \ \forall s'. \ (s \symstep s') \rightarrow \big(\infeasible(s') \lor (\exists t \in l. \ \safeet(t) \ \land \ s' \equivstate t.\attrstate) \big)
}
{
    \safeet(\tree(s, l))
}
\end{array}
\]
\end{definition}

In the next theorem,
we prove that if the execution tree of the whole program satisfies the safety property described above,
then the program is safe w.r.t. the non-speculative concrete semantics.

\begin{lemma}
\label{lemma:safety-via-et-ns-step}
Let $s_0 \triangleq \initsymstate(\module)$, and $l$ be a list of execution trees.
If $\module$ is supported and $\safeet(\tree(s_0, l))$, then $\issafens(\module)$.
\end{lemma}

% theorem 2 (+ ns lemma)

\begin{theorem}
\label{theorem:safety-via-et}
Let $s_0 \triangleq \initsymstate(\module)$, and $l$ be a list of execution trees.
If $\module$ is supported and $\safeet(\tree(s_0, l))$, then $\issafe(\module)$.
\end{theorem}
