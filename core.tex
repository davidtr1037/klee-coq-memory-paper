\section{...}
\label{sec:core}

\input{symbolic-semantics.tex}

\subsection{Reachability Completeness}

\begin{definition}
A concrete state $c \triangleq \progstate{\location}{\localstore}{\stack}{\memory}$ is \emph{poison-free}
if $\localstore$, $\stack$, and $\memory$ do not contain $\tpoison$ values.
Let $c$ and $c'$ be two concrete states.
We say that there is a \emph{non-speculative} step between $c$ and $c'$, denoted by $c \nsstep c'$,
if $c \step c'$ and both $c$ and $c'$ are poison-free.
\end{definition}

\begin{definition}
\label{def:issafe-ns-step}
Let $c_0 \triangleq \initstate(\module)$,
then $\module$ is \emph{safe} w.r.t. the non-speculative concrete semantics, denoted by $\issafens(\module)$, if:
\[ \forall c. \ c_{0} \multinsstep c \implies \neg \errorstate(c) \]
(The relation $\multinsstep$ is the reflexive-transitive closure of the relation $\nsstep$.)
\end{definition}

\begin{lemma}
\label{lemma:multi-ns-step-relative-completeness}
Let $c$ and $c'$ be concrete states.
If $\module$ is supported, $c$ is poison-free, no error states can be derived from $c$ using the $\multinsstep$ relation, and $c \multistep c'$,
then $c \multinsstep c'$.
\end{lemma}

\begin{theorem}
\label{theorem:completeness}
Let $c_{0} \triangleq \initstate(\module)$, and let $s_{0} \triangleq \initsymstate(\module)$.
If $\module$ is supported and $c_{0} \multinsstep c$,
then there exists a symbolic state $s$ such that $s_{0} \symmultistep s$ and $s \overapprox c$.
\end{theorem}

\subsection{Program Safety via Execution Trees}

\begin{definition}
The symbolic stores $\symlocalstore_1$ and $\symlocalstore_2$ are \emph{equivalent}, denoted by $\symlocalstore_1\equiv
\symlocalstore_2$, if they are defined over the same variables,
and for each such variable $x$, $\mapaccess{\symlocalstore_1}{x} \equiv \mapaccess{\symlocalstore_2}{x}$.
The symbolic frames $\symstackframe{\location_1}{\symlocalstore_1}{x_1}$ and $\symstackframe{\location_2}{\symlocalstore_2}{x_2}$ are \emph{equivalent} if
$\location_1 = \location_2$, $\symlocalstore_1 \equiv \symlocalstore_2$, and $x_1 = x_2$.
The symbolic stacks $\symstack_1$ and $\symstack_2$ are \emph{equivalent}, denoted by $\symstack_1 \equiv \symstack_2$,
if their elements are pointwise equivalent.
The symbolic memory objects $(\addr_1, \size_1, \smtarray_1)$ and $(\addr_2, \size_2, \smtarray_2)$ are \emph{equivalent} if
$\addr_1 = \addr_2$, $\size_1 = \size_2$, and $\smtarray_1 \equiv \smtarray_2$.
The symbolic memories $\symmemory_1$ and $\symmemory_2$ are \emph{equivalent}, denoted by $\symmemory_1 \equiv \symmemory_2$,
if their elements are pointwise equivalent.
The symbolic states $s_1 \triangleq \symstate{\location_1}{\symlocalstore_1}{\symstack_1}{\symmemory_1}{\pc_1}$ and $s_2 \triangleq \symstate{\location_2}{\symlocalstore_2}{\symstack_2}{\symmemory_2}{\pc_2}$ are \emph{equivalent},
denoted by $s_1 \equiv s_2$, if $\location_1 = \location_2$, $\symlocalstore_1 \equiv \symlocalstore_2$, $\symstack_1 \equiv \symstack_2$, $\symmemory_1 \equiv \symmemory_2$, and $\pc_1 \equiv \pc_2$.
\end{definition}

\begin{lemma}
\label{lemma:safety-via-et-ns-step}
Let $s_0 \triangleq \initsymstate(\module)$, and $l$ be a list of execution trees.
If $\module$ is supported and $\safeet(\tree(s_0, l))$, then $\issafens(\module)$.
\end{lemma}

\begin{theorem}
\label{theorem:safety-via-et}
Let $s_0 \triangleq \initsymstate(\module)$, and $l$ be a list of execution trees.
If $\module$ is supported and $\safeet(\tree(s_0, l))$, then $\issafe(\module)$.
\end{theorem}
