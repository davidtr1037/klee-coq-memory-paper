\section{Evaluation}
\label{sec:evaluation}

In our evaluation, we use the following modes:
\proofopt is the proof-generating mode, and \base is vanilla \klee.
As mentioned in~\Cref{sec:implementation},
some of the SMT transformations are not supported by our formalization.
Therefore, these transformations are disabled in \proofopt.

The following research questions guide our evaluation:
\begin{itemize}
    \item \textbf{RQ1}: Can our approach generate valid proofs?
    \item \textbf{RQ2}: What is the overhead of proof generation during symbolic execution?
    % TODO: proof size?
    \item \textbf{RQ3}: What is the time required to validate the generated proofs?
\end{itemize}

\subsection{Setup}

Each mode is run using the following configuration:
The search heuristic is set to DFS,
the timeout is set to one hour,
the memory limit is set to 4GB,
and the SMT solver is set to STP 2.3.3~\cite{stp}.
In all the modes, we measure the following metrics:
analysis time, number of explored paths, and number of executed instructions.
In the \proofopt mode,
we use \coqc to validate the generated proofs,
and we measure the \emph{proof time}, \ie the time required to compile the proof using \coqc,
and the \emph{proof size}, \ie the size of the compiled proof file (\code{.vo} file) created by \coqc.
We performed our experiments on Ubuntu 24.04,
equipped with Intel Core i9-9900 and 32GB of RAM.

\subsection{Benchmarks}

% TODO: add citations to benchmarks
% TODO: which SE paper uses SVComp?
Our implementation supports memory operations,
so our goal is to evaluate it on programs with memory manipulations.
For this, we selected several benchmarks (\libtasn, \libosip, \coreutils, and \svcomp) that were used in the past in the context of \SE~\cite{klee,symsize-model,klee-rocq}.
In \libtasn and \libosip, we selected a set of APIs,
and for each API we constructed a test driver that runs it with symbolic inputs (integers, arrays, strings, \etc).
To symbolically execute the programs in \coreutils,
one needs to support external calls and model the environment (command-line arguments, file system, \etc).
As our implementation currently does not support these features,
we could not evaluate those programs directly.
However, \coreutils contains a library of APIs, some of which can be tested in isolation.
We selected a subset of such APIs,
and constructed test drivers that run these APIs with symbolic inputs.
In \svcomp, we selected a subset of programs from the \textit{array-memsafety} section.
Most of these programs perform memory allocations with symbolic sizes,
which are currently unsupported by both \klee and our approach.
To overcome this, we modified the relevant parts in these programs to perform fixed-size memory allocations instead.

\subsection{Results}

The results are shown in~\Cref{table:results}.
% TODO ...

\begin{table*}[t]
\caption{...}
\label{table:results}
\centering
\scriptsize{
\begin{tabular}{|l|r|r|r|r|r|r|}
\cline{1-7}
\multicolumn{1}{|c|}{} &
\multicolumn{2}{c|}{\textbf{Time}} &
\multicolumn{1}{c|}{\textbf{Proof Time}} &
\multicolumn{1}{c|}{\textbf{Proof Size}} &
\multicolumn{1}{c|}{\textbf{\#Paths}} &
\multicolumn{1}{c|}{\textbf{\#Inst}} \\
\cline{2-7}
\multicolumn{1}{|c|}{} &
\multicolumn{1}{c|}{\makecell{\textbf{Base}}} &
\multicolumn{1}{c|}{\makecell{\textbf{PG}}} & & & & \\
\hline
A & 0.1 & 0.1 & 1.4 & 1.9 & 4 & 82 \\ \hline
\end{tabular}
}
\end{table*}
