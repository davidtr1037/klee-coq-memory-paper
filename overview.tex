\section{Proof Logging via Symbolic Execution}
\label{sec:overview}

% TODO: and also show the required delta to support ...
In this section, we give an overview of the proof logging approach presented in~\cite{klee-rocq},
which generates machine-checked safety proofs using symbolic execution.

To construct a safety proof for a given program,
\ie show that the execution of the program according to the concrete \llvm semantics does not result in errors,
we rely on certain properties related to the execution tree of the program,
a data structure that records the paths explored during the analysis of the program.
More specifically,
we prove a theorem stating that if the execution tree of the program is \emph{error-free} and \emph{complete},
then the program is safe with respect to the concrete \llvm semantics.
An execution tree is error-free if it does not contain symbolic error states,
and it is complete if every feasible symbolic state derivable by the symbolic \llvm semantics can be paired by an equivalent symbolic state in the execution tree.

To apply this theorem, we need to provide an execution tree that satisfies the safety properties mentioned above.
To do so,
we instrument the \SE engine to generate an execution tree along with a proof showing that it satisfies the required properties.
Therefore, the final output is a \coq proof consisting of two sections:
The first one is developed manually and contains the formalized semantics and the supporting theory,
and the second one is generated by the \SE engine during the analysis.
With this approach, the trusted computing base contains the kernel of \coq, and the SMT solver.

%The implementation provided in~\cite{klee-rocq} is restricted to a subset of \llvm with integers.
%In the nexst section,
%we outline the additional effort required to extend that approach of a subset of \llvm with memory operations.
