\section{Symbolic-Execution Proof-Logging Framework}
\label{sec:overview}

% TODO: and also show the required delta to support ...
In this section, we give an overview of the proof logging approach presented in~\cite{klee-rocq},
which generates machine-checked safety proofs using symbolic execution.

%\si{Define what it means for a program to be safe (without going into the details of what an error state is)}

\begin{paragraph}{\bf Program safety.~}
For a program to be \emph{safe} it is required that no
execution of the program lead to so-called
\emph{error states}.
To make such claims formally, \cite{klee-rocq} defines
a concrete semantics of (a subset of) \llvm IR, based
on Vellum~\cite{vellum}. This comprises of a definition
of the space of concrete states $\States$ and a small-step relation ${\to} \subseteq \States^2$.
It then defines the subset of error states, which intuitively consists of states where an invalid operation is about to take place, or where a user-defined assertion is violated.
\end{paragraph}

\si{explain that the artifact from the SE is an execution tree}

\begin{paragraph}{\bf Analyzing execution trees.~}
When SE terminates, the paths explored during the analysis
of the program form an \emph{execution tree}, whose nodes
correspond to \emph{symbolic states} that the engine has
computed.
Each such symbolic states represents a set of concrete states.
In order to be able to generate, from an execution tree, a
formal proof of program safety, without having to reason
directly on the concrete states and the concrete semantics---%
which would be quite involved and cumbersome---%
the development in~\cite{klee-rocq} provides foundation in the
form of a theory that lifts the entire reasoning to the
symbolic state space.\si{still have to incorporate some content from the commented text below}
\end{paragraph}

\begin{comment}
To construct a safety proof for a given program,
%\ie show that the execution of the program according to the concrete \llvm semantics does not result in errors,
we rely on certain properties related to the execution tree of the program,
a data structure that records the paths explored during the analysis of the program.
More specifically,
we prove a theorem stating that if the execution tree of the program is \emph{error-free} and \emph{complete},
then the program is safe with respect to the concrete \llvm semantics.
An execution tree is error-free if it does not contain symbolic error states,
and it is complete if every feasible symbolic state derivable by the symbolic \llvm semantics can be paired by an equivalent symbolic state in the execution tree.
\end{comment}

\begin{paragraph}{\bf Symbolic semantics \& reachability completeness.~}
Alongside the concrete states and semantics ($\States$, $\to$),
\cite{klee-rocq} defines analogue \emph{symbolic states} and
\emph{symbolic (small-step) semantics} ($\SymStates$, $\symstep$).
The symbolic state space is the same one used by SE engines,
where SMT-like expressions replace concrete values.

A central theorem of this construction is \emph{reachability completeness}: forall $s_0, s \in \States$ s.t.\@ $s_0$ is an initial state and $\s_0 \to^* s$, there exist corresponding $\tilde{s}_0, \tilde{s}\in \SymStates$ such that $\tilde{s}_0$ is an initial (symbolic) state and $\tilde{s}$ \emph{represents} $s$, in the sense that $s$ can be obtained from $\tilde{s}$ via substituting the symbolic variables occuring in it with appropriate concrete values.

%\si{put in the definition of reachability completeness without going into the details of n.s.\@ semantics and also leaving out the definition of the initial state}
\end{paragraph}

\si{Put in the theorem that says safe-et $\to$ safe program}

\si{explain that is remains to prove that safe-et holds, which is done by proof generation, relying on the SMT queries as axioms}

To apply this theorem, we need to provide an execution tree that satisfies the safety properties mentioned above.
To do so,
we instrument the \SE engine to generate an execution tree along with a proof showing that it satisfies the required properties.
Therefore, the final output is a \coq proof consisting of two sections:
The first one is developed manually and contains the formalized semantics and the supporting theory,
and the second one is generated by the \SE engine during the analysis.
With this approach, the trusted computing base contains the kernel of \coq, and the SMT solver.


%The implementation provided in~\cite{klee-rocq} is restricted to a subset of \llvm with integers.
%In the nexst section,
%we outline the additional effort required to extend that approach of a subset of \llvm with memory operations.
