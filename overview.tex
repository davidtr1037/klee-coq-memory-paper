\section{Proof Logging via Symbolic Execution}
\label{sec:overview}

\newenvironment{chunk}[1]
    {\noindent{\bf #1.}
    }
    { 
    }

%In this section, we give an overview of the proof logging approach presented in~\cite{klee-rocq},
%which generates machine-checked safety proofs using symbolic execution.

In this paper, we extend the proof-logging approach presented in~\cite{klee-rocq} to support a subset of \llvm with memory operations.
Before diving into the details, we give a high-level overview of~\cite{klee-rocq}.
Later, in~\Cref{sec:core},
we give a detailed presentation of our extension,
which requires a substantial theoretical development and a significant engineering effort.

%\si{Define what it means for a program to be safe (without going into the details of what an error state is)}

{\it Program Safety.}
A program is considered safe if its execution cannot reach a so-called \emph{error state}.
To formalize this,
\cite{klee-rocq} defines a concrete semantics of (a subset of) \llvm IR, based on \vellvm~\cite{vellvm}.
This comprises of a definition of the space of concrete states $\States$ and a small-step transition relation ${\to} \subseteq \States \times \States$.
It then defines the subset of error states,
which intuitively consists of states where an invalid operation is about to occur or where a user-defined assertion is violated.

{\it Execution Trees.}
When \SE terminates, the paths explored during the analysis of the program form an \emph{execution tree},
whose nodes correspond to the \emph{symbolic states} computed by the \SE engine.
Each such symbolic state represents a set of concrete states.
%To generate a formal proof of program safety from an execution tree without reasoning directly about the concrete states and the concrete semantics,
%which would be complex and cumbersome,
%the development in~\cite{klee-rocq} provides a theoretical foundation that lifts the entire reasoning to the symbolic state space.

\begin{comment}
To construct a safety proof for a given program,
%\ie show that the execution of the program according to the concrete \llvm semantics does not result in errors,
we rely on certain properties related to the execution tree of the program,
a data structure that records the paths explored during the analysis of the program.
More specifically,
we prove a theorem stating that if the execution tree of the program is \emph{error-free} and \emph{complete},
then the program is safe with respect to the concrete \llvm semantics.
An execution tree is error-free if it does not contain symbolic error states,
and it is complete if every feasible symbolic state derivable by the symbolic \llvm semantics can be paired by an equivalent symbolic state in the execution tree.
\end{comment}

{\it Program Safety via Symbolic Semantics.}
Alongside the concrete space ($\States$, $\to$),
\cite{klee-rocq} defines analogue \emph{symbolic states} and
\emph{symbolic semantics} ($\SymStates$, $\symstep$).
The symbolic state space coincides with that used by \SE engines,
where SMT-like expressions replace concrete values.
A central result of this construction is \emph{reachability completeness}, which lifts the entire reasoning to the symbolic domain:
For all $s_0, s \in \States$ s.t.\@ $s_0$ is an initial state, $s_0 \to^* s$, and this sequence of transitions does not introduce $\tpoison$ values~\cite{llvmref},
then there exist $\tilde{s}_0, \tilde{s}\in \SymStates$ such that $\tilde{s}_0$ is an initial symbolic state,
$\tilde{s}_0\,{\symstep}{}^*\,\tilde{s}$, and $\tilde{s}$ \emph{represents} $s$,
in the sense that $s$ can be obtained from $\tilde{s}$ by substituting symbolic variables with appropriate concrete values.
This yields the \emph{program safety} theorem:
If an execution tree is \emph{complete}, \ie its paths cover all the feasible states according to the symbolic semantics,
and if the states in the execution tree represent only non-error states,
then the analyzed program is safe.

{\it Proof Generation.}
To apply this theorem, we need to provide an execution tree that satisfies the safety properties mentioned above.
To do so, we instrument the \SE engine to generate an execution tree along with a proof showing that it satisfies the required properties.
Therefore, the final output is a \coq proof consisting of two sections:
The first one is developed manually and contains the formalized semantics and the theoretical foundation,
and the second one is generated by the \SE engine during the analysis.
With this approach, the trusted computing base contains the kernel of \coq, and the SMT solver.

%The implementation provided in~\cite{klee-rocq} is restricted to a subset of \llvm with integers.
%In the nexst section,
%we outline the additional effort required to extend that approach of a subset of \llvm with memory operations.
