\section{Symbolic-Execution Proof-Logging Framework}
\label{sec:overview}

% TODO: and also show the required delta to support ...
In this section, we give an overview of the proof logging approach presented in~\cite{klee-rocq},
which generates machine-checked safety proofs using symbolic execution.

%\si{Define what it means for a program to be safe (without going into the details of what an error state is)}

{\it Program Safety.}
A program is considered safe if its execution cannot reach a so-called \emph{error state}.
To formalize this,
\cite{klee-rocq} defines a concrete semantics of (a subset of) \llvm IR, based on \vellvm~\cite{vellvm}.
This comprises of a definition of the space of concrete states $\States$ and a small-step transition relation ${\to} \subseteq \States \times \States$.
It then defines the subset of error states,
which intuitively consists of states where an invalid operation is about to occur or where a user-defined assertion is violated.

\si{explain that the artifact from the SE is an execution tree}

{\it Analyzing Execution Trees.}
When \SE terminates, the paths explored during the analysis of the program form an \emph{execution tree},
whose nodes correspond to the \emph{symbolic states} computed by the \SE engine.
Each such symbolic state represents a set of concrete states.
To generate a formal proof of program safety from an execution tree---
without reasoning directly about the concrete states and the concrete semantics, which would be complex and cumbersome---
the development in~\cite{klee-rocq} provides a theoretical foundation that lifts the entire reasoning to the symbolic state space.
\si{still have to incorporate some content from the commented text below}

\begin{comment}
To construct a safety proof for a given program,
%\ie show that the execution of the program according to the concrete \llvm semantics does not result in errors,
we rely on certain properties related to the execution tree of the program,
a data structure that records the paths explored during the analysis of the program.
More specifically,
we prove a theorem stating that if the execution tree of the program is \emph{error-free} and \emph{complete},
then the program is safe with respect to the concrete \llvm semantics.
An execution tree is error-free if it does not contain symbolic error states,
and it is complete if every feasible symbolic state derivable by the symbolic \llvm semantics can be paired by an equivalent symbolic state in the execution tree.
\end{comment}

\begin{paragraph}{\bf Symbolic semantics \& reachability completeness.~}
Alongside the concrete states and semantics ($\States$, $\to$),
\cite{klee-rocq} defines analogue \emph{symbolic states} and
\emph{symbolic (small-step) semantics} ($\SymStates$, $\symstep$).
The symbolic state space is the same one used by SE engines,
where SMT-like expressions replace concrete values.

A central theorem of this construction is \emph{reachability completeness}: forall $s_0, s \in \States$ s.t.\@ $s_0$ is an initial state and $s_0 \to^* s$, there exist corresponding $\tilde{s}_0, \tilde{s}\in \SymStates$ such that $\tilde{s}_0$ is an initial (symbolic) state, $\tilde{s}_0\symstep^*\tilde{s}$, and $\tilde{s}$ \emph{represents} $s$, in the sense that $s$ can be obtained from $\tilde{s}$ via substituting the symbolic variables occuring in it with appropriate concrete values.

From that follows the \emph{program safety theorem} stating that if we have an
execution tree, and we can show that it is \emph{complete}---%
\ie the paths therein cover all of the reachable \emph{symbolic} states,
according to the formal symbolic semantics---%
and if the states in the tree represent only non-error states,
then the analyzed program is safe.
\end{paragraph}


\begin{paragraph}{\bf Proof generation.~}
%
To apply this theorem, we need to provide an execution tree that satisfies the safety properties mentioned above.
To do so,
we instrument the \SE engine to generate an execution tree along with a proof showing that it satisfies the required properties.
Therefore, the final output is a \coq proof consisting of two sections:
The first one is developed manually and contains the formalized semantics and the supporting theory,
and the second one is generated by the \SE engine during the analysis.
With this approach, the trusted computing base contains the kernel of \coq, and the SMT solver.
\end{paragraph}

%The implementation provided in~\cite{klee-rocq} is restricted to a subset of \llvm with integers.
%In the nexst section,
%we outline the additional effort required to extend that approach of a subset of \llvm with memory operations.
