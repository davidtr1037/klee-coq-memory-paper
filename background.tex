\section{Background}
\label{sec:background}

% TODO: explain bit-vectors
% TODO: explain SMT

Add some general background about LLVM here...

LLVM IR is an industry-standard intermediate representation for low-level languages, esp.
C, C++, and Rust.
In addition to its uses for compilation, it is
also used by analysis tools such as model checkers and symbolic execution engines.
We describe below the aspects of \llvm that are relevant for our development.

\subsection{LLVM Memory Model}

\llvm supports scalar types, array types, structures, and pointers.
For the purposes of this paper, suffices that we focus on integral types, array types, and pointers.
%
\[
\tau ::= \bvsort{$w$} \;|\;
         \texttt{[}n \times \tau\texttt{]} \;|\;
         \tau\texttt{*}
\]

Scalar types can be of any positive bitwidth $w$,
and arrays are parametrized by a dimension $n$,
with multi-dimentional arrays taking the form of nested arrays.
Pointers are typed---that is, the type of the pointed data is explicit.
The width of the pointer itself is fixed.

We use the notation $n@\bvsort{$w$}$ to denote a scalar value of type $\bvsort{$w$}$ whose integral (either signed or unsigned) value is $n$.

\llvm defines a \emph{data layout}, which specifies how data is to be laid out in memory.
%The data layout consists of a list of specifications,
%including endianness, alignment rules, \etc
In particular, it defines various properties related to pointers, such as \emph{pointer type} and \emph{index type}.
The pointer type specifies the integral type used to represent pointer values.
The index type specifies the type used for address calculations (\eg in \tgep).
The size of the index type may not exceed the size of the pointer type.
In addition, the index type also specifies the type used to represent the size of allocated objects.

% TODO: assumptions in this paper (KLEE)

\subsection{Concrete Semantics}
\label{sec:concrete-semantics}

% TODO: ignore alignment details
% TODO: we assume that the argument of malloc is a constant
% TODO: add type to malloc/free/gep?
% TODO: say that we assume: pointer type = i64 / index type = i32
% TODO: say the LLVM allows some freedom in the repr of memory objects / address spaces / etc.
% TODO: UB is interpreted as an error
% TODO: fix the Malloc rule (set the parameter type to i32?)?
% TODO: fix the Assume rule (set the parameter type to i1?)?

The \llvm standard documentation provides some leeway in how memory is viewed and addressed.
The most common depiction of program memory (a.k.a.\@ the ``flat model'') is a single, large block of memory bytes, with addresses being simple byte indexes.
In this work, we take a slightly different approach---the \emph{memory-object model}---%
which is more compatible with the workings of
symbolic execution w.r.t.\@ memory allocation
and manipulation.

\begin{definition}
A \emph{concrete heap}, according to the memory-object model, is a mapping from (half-open, integer) intervals to arrays of bytes of a corresponding size.
%
\[
\begin{array}{l}
H = \Intervals^{\indextype} \rightharpoonup (\Vals^{\bvsort{8}}\cup\{\tundef, \tpoison\})[\,]
\\
\Intervals^{\tau} \eqdef \{[b,e) \mid b,e\in \!\Vals^{\tau}\!, \,b\leq e\}
\end{array}
\]

With the following properties for $h\in\Heaps$:
\begin{itemize}
\item $\mathrm{dom}~h$ are pairwise-disjoint intervals.
\item $|h(\iota)| = |\iota|$ for all $\iota\in\mathrm{dom}~h$.
\end{itemize}
\end{definition}

A \emph{memory object} is defined as a tuple:
\[ (\addr, \size, \arrayvalue) \in \Vals^{\pointertype} \times \Vals^{\indextype} \times \Arrays \quad \quad \Arrays \triangleq \Z \rightarrow \Vals^{\bvsort{8}} \cup \{\tundef, \tpoison\} \]
A memory object has a base address $\addr$, a size $\size$, and mapping $\arrayvalue$ which tracks the stored values.
A stored value can be either a value of type $\Vals^{\bvsort{8}}$ (\ie a byte) or one of the special values $\tundef$ or $\tpoison$.
The memory is defined using a \emph{heap} and an \emph{allocator}.
A heap $\heap \in \Heaps$ is a set memory objects.
An allocator is an algorithm that defines the allocation scheme of memory objects.
Whenever an allocator adds a new memory object to the heap,
the address interval of that memory object must not overlap with the address intervals of existing memory objects.
In addition, an address interval must not wrap around the address space, \ie it must hold that:
\[ \addr \leq \addr + \size \]

% TODO: modeling a generic allocator is hard...
In this work, we assume a linear allocator that allocates memory objects in an ascending order while maintaining a constant gap (also known as \emph{red-zone}) between memory objects.

\subsubsection{\textit{Malloc.}}
When allocating a memory object,
the size of the allocation must be non-negative and must not exceed the largest signed integer that fits into the index type.
As mentioned before, the address interval of the allocated memory object must not wrap around the address space.
If one of these properties is violated, the result is undefined-behavior.
The mapping of the newly allocated memory object is set to a function that maps all the indices to a pre-defined value (byte).

\subsubsection{Free}
% TODO: assume that the type of p is iptr?
When deallocating a pointer value $p$,
we first check if there exists a memory object $(\addr, \size, \arrayvalue)$ in the heap $h$ such that $p = \addr$.
If that is the case, then we remove that memory object from the heap $h$.
Otherwise, the result is undefined-behavior.

\subsubsection{Load}
% TODO: what happens if p is undef/poison?
When reading $n$ bytes from a pointer value $p$,
we need to make sure that there exists a memory object $(\addr, \size, \arrayvalue)$ in the heap $h$ such that (1) $p < p + n$ and (2) $\addr \leq p < \addr + \size$.
If that is not the case, then the result is undfined-behavior.
Otherwise, we use the \textit{read} procedure to obtain the accessed value.
This procedure first reads the corresponding sequence of stored values.
If one of these values is $\tpoison$, then it returns $\tpoison$.
If one of these values is $\tundef$, then it returns $\tundef$.
Otherwise, we deserialize this sequence of values (bytes) into an integer of the appropriate type.

\subsubsection{Store}
% TODO: what happens if p/v is undef/poison?
When writing a value $v$ to a pointer value $p$,
we need to make sure that there exists a memory object $(\addr, \size, \arrayvalue)$ in the heap $h$ such that (1) $p < p + n$ and (2) $\addr \leq p < \addr + \size$.
If that is not the case, then the result is undfined-behavior.
Otherwise, we use the \textit{write} procedure to store the value $v$.
This procedure serializes the value $v$ into a sequence of bytes and updates the array $\arrayvalue$ accordingly.

\subsubsection{GetElementPtr}
% TODO: mention flags (nuw, nusw, inbounds)
% TODO: address --> pointer?
% TODO: index / offset
% TODO: link to the lines

The $\tgep$ instruction computes the address of a subelement of an aggregate data structure (array, struct, \etc.).
Note that it only performs address calculations without accessing the memory.
The first argument is the base pointer to start from,
and the remaining arguments are indices that indicate which of the elements of the aggregate object are indexed.
The interpretation of each index dependends on the type being indexed into.
The first index is always indexed into the base pointer type,
the second index is indexed into the element type of the base pointer type, \etc
The first indexed type must be a pointer type, and subsequent types can be either array types or struct types.

The semantics of $\tgep$ is given in~\Cref{alg:gep}.
All the indices are first converted to values of the index type (sign-extended or truncated), and then translated into offsets.
The first index $j_0$ is used to move accross the elements corresponding to the base pointer type,
so it is multiplied by the type size of the element type of the base pointer type (\cref{line:first-index}).
The remaining indices $\overline{j}$ are translated into offsets based on the indexed type.
If the indexed type is an array type,
then the index is multiplied by the type size of the indexed type (\cref{line:array-index}).
If the indexed type is a struct type,
then the index is translated into a field selector (\cref{line:struct-index}).
The computed offsets are sequentially summed up,
and then the resulting offset is converted to the pointer type and added to the base pointer $p$.

% TODO: add modified pseudo-code?
The $\tgep$ instruction may have attributes (\opcode{nuw}, \opcode{nusw}, and \opcode{inbounds}) that impose additional rules.
For example, if the \opcode{nuw} attribute is enabled, then the following must hold:
(1) if the type of an index is larger than the index type, the truncation to the index type must preserve the unsigned value,
(2) the multiplication of an index by the type size does not wrap the index type in an unsigned sense, and
(3) the successive addition of each offset does not wrap the index type in an unsigned sense.
If one of these conditions is violated, the result is $\tpoison$.

%First, we compute the value of the base pointer $e$ and then the values of the indices $e_i$.
%Then, to compute the resulting pointer, we invoke \textit{eval\_gep}.
%The complete semantics of \tgep is rather complicated,
%so we first describe a simplified version of its semantics in ...
%...
%If $p$ is poison/undef, then
%If one of the indices is poison, then
%If one of the indices is undef, then
%Otherwise, all the arguments are integral values and ...

\begin{figure}
\scalebox{0.9}{
$
\begin{array}{l@{~}r@{~{}~}l}
  \tbinop & ~::={} & \opcode{add} ~|~ \opcode{sub} ~|~ \opcode{mul} ~|~ \opcode{urem} ~|~ \sdots \\
  \tcmpop & ~::={} & \opcode{eq} ~|~ \opcode{ne} ~|~ \opcode{ugt} ~|~ \opcode{uge} ~|~ \opcode{ult} ~|~ \opcode{ule} ~|~ \sdots \\
  \toper & ~::={} & binop ~|~ \opcode{icmp}_{cmpop} \\
  \tcast & ~::={} & \opcode{zext} ~|~ \opcode{sext} ~|~ \opcode{trunc} ~|~ \opcode{bitcast} \\
  e & ~::={} & n ~|~ x ~|~ \toper^\tau~e_1~e_2 ~|~ \tcast^{\tau\to\tau'}~e \\
  \tinstr & ~::={} & x ~\texttt{=}~ e \ | \ x ~\texttt{=}~ \tphi^\tau~\{\,\overline{b_i\mapsto e_i}\,\} \ | \ \tbr~b \ | \ \tbr~e~b_1~b_2 \ | \\
          & & \tcall~\tid~(\overline{\tau_i~e_i}) \ | \ x ~\texttt{=}~ \tcall^{\tau}~\tid~(\overline{\tau_i~e_i}) \ | \ \tret \ | \ \tret^{\tau}~e \ | \ \tunreachable \ | \\
          & & x ~\texttt{=}~ \tload^{\tau}~e \ | \ \tstore^{\tau}~e_1~e_2 \ | \ \tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)} \\
  \tblk & ~::={} & \tid{:}~\overline{\tinstr} \\
  \tfunc & ~::={} & \tdef~\tau~\tid(\overline{\tau_i~x_i})
                   ~ \{~\overline{\tblk}~\} \\
  \tmodule & ~::={} & \overline{\tfunc}
\end{array}
$
}
\caption{A simplified syntax of \llvm IR.}
\label{figure:llvm-syntax}
\end{figure}

\begin{figure}
\[
\begin{array}{cl}
\ruledefsmall{Assign}{
  \instrat{\location} = \codequote{v~\texttt{=}~e} \quad
  e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
  \welldef{\evalexprty{e}\localstore\tau \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto \evalexprty{e}\localstore\tau]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Branch-True}{
  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1 \quad
  \welldef{\location\triangleright b_i \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\location\triangleright b_1}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Branch-True}{
  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{0}1 \quad
  \welldef{\location\triangleright b_i \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\location\triangleright b_2}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Make-Symbolic}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{32}}~\intrinsicfunc{make\_symbolic}()}
  \quad n \in \Z
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto n@\bvsort{32}]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Assume}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{assume}(e)} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Malloc}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\pointertype}~\intrinsicfunc{malloc}(e)} \quad
  \evalexprty{e}{\localstore}{\indextype} = n \quad
  \allocate(\memory, n) = (\memory', p) \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto p]}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Free}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{free}(e)} \quad
  \evalexprty{e}{\localstore}{\pointertype} = p \quad
  \mo \in \memory \quad
  \isbaseaddr{p}{\mo} \quad
  \mathit{remove}(\memory, \mo) = \memory'
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Load}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\localstore}{\pointertype} = p \quad
  \mo \in \memory \quad
  \isinbounds{p}{|\tau|}{\mo} \quad
  \mathit{read}(\mo, p, \tau) = v \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto v]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Store}{
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\localstore}{\tau} = v \quad
  \evalexprty{e_2}{\localstore}{\pointertype} = p \quad
  \mo \in \memory \quad
  \isinbounds{p}{|\tau|}{\mo} \quad
  \mathit{write}(\mo, p, v) = \mo' \quad
  \mathit{replace}(\memory, \mo') = \memory'
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{GetElementPtr}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}} \quad
  |\overline{(\tau_i, e_i)}| > 0 \quad
  \evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p \quad
  \evalexprty{e_i}{\localstore}{\tau_i} = j_i \quad
  \evalgep(\tau, p, j_0, [...]) = v
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto v]}{\stack}{\memory}
}
\end{array}
\]
\caption{Operational small-step semantics of \llvm IR.}
\label{figure:llvm-semantics}
\end{figure}

\begin{algorithm}[t]
\caption{The semantics of $\tgep$ (without attributes).}
\label{alg:gep}
\begin{algorithmic}[1]

\Function{compute-offset}{$\tau, o, \overline{j}$}
    \If {$|\overline{j}| = 0$}
        \State \Return $o$
    \EndIf
    \State $\overline{j} \gets j_1 :: \overline{j'}$
    \If {$\tau = \arraytype{\tau'}$}
        \State $o \gets o + \convert_{\indextype}(j_1) \cdot |\tau'|$ \label{line:array-index}
        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
    \EndIf
    \If {$\tau = \structtype{\overline{\tau}}$}
        \State ...
    \EndIf
    \State ...
\EndFunction

\Function{eval\_gep}{$\tau, p, j_0, \overline{j}$}
    \If {$j_0 = \tpoison \ \textbf{or} \ \tpoison \in \overline{j}$}
        \State \Return $\tpoison$
    \EndIf
    \If {$j_0 = \tundef \ \textbf{or} \ \tundef \in \overline{j}$}
        \State \Return $\tundef$
    \EndIf
    \State $o \gets \convert_{\indextype}(j_0) \cdot |\tau|$ \label{line:first-index}
    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
    \State \Return $p + \zeroext_{\pointertype}(r)$
\EndFunction

\end{algorithmic}
\end{algorithm}

% TODO: some text before?
\begin{definition}
\label{def:error-state}
Let $c \triangleq \progstate{\location}{\localstore}{\stack}{\memory}$ be a concrete state.
Then $c$ is an \emph{error} state, denoted by $\errorstate(c)$, if one of the following holds:
\begin{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{\tunreachable}$}$
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ op \ \bvsort{w} \ e_1 \ e_2}$}$, and one of the following holds, where $v_k \triangleq \evalexprty{e_k}{\localstore}{\bvsort{w}}$:
    \begin{enumerate}[left=-3pt]
        \item \textup{$op \in \{\opcode{udiv}, \opcode{sdiv}, \opcode{urem}, \opcode{srem}\}$ and $v_2 = \bvval{0}{w}$}
        \item \textup{$op = \opcode{sdiv}$, $v_1 = \bvval{(-2^{w - 1})}{w}$, and $v_2 = \bvval{(-1)}{w}$}
        \item \textup{$op \in \{\opcode{shl}, \opcode{lshr}, \opcode{ashr}\}$ and $v_2 = \bvval{n}{w}$, and $n \geq w$}
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tcall^{\pointertype} \ \intrinsicfunc{malloc}(e)}$}$, and the following holds:
    \begin{enumerate}
        \item \textup{$\evalexprty{e}{\localstore}{\tau} > max\_signed_{\bvsort{32}}$}
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{\tcall~\intrinsicfunc{free}(e)}$}$, and the following holds:
    \begin{enumerate}
        \item $\evalexprty{e}{\localstore}{\tau} = p$
        \item $\invalidbaseaddress(\memory, p)$
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tload^{\tau} \ e}$}$, and the following holds:
    \begin{enumerate}
        \item $\evalexprty{e}{\localstore}{\tau} = p$
        \item $\invalidpointer(\memory, p, |\tau|)$
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{\tstore^{\tau} \ e_1 \ e_2}$}$, and the following holds:
    \begin{enumerate}
        \item $\evalexprty{e_2}{\localstore}{\tau} = p$
        \item $\invalidpointer(\memory, p, |\tau|)$
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tgep~\pointertypeof{\tau} \ e \ \overline{(\tau_i, e_i)}}$}$, and the following holds:
    \begin{enumerate}
        % TODO: needed?
        % \item $|\overline{(\tau_i, e_i)}| > 0$
        \item $\evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p$ and $\evalexprty{e_i}{\localstore}{\tau_i} = j_i$
        \item $\evalgep(\tau, p, j_0, [...]) = \tpoison$
    \end{enumerate}
\end{enumerate}
where:
\[
\begin{array}{ll}
    \invalidpointer(\memory, p, n) & \triangleq \forall \mo \in \memory. \ \neg \isinbounds{p}{n}{\mo} \\
    \invalidbaseaddress(\memory, p) & \triangleq \forall \mo \in \memory. \ \neg \isbaseaddr{p}{\mo}
\end{array}
\]
\end{definition}

\begin{definition}
\label{def:safety}
Let $f$ be the entry function in the module $\module$.
The \emph{initial state} is defined as:
\[ \initstate(\module) \triangleq \progstate{f\hspace{-2pt}.\funcentry}{\{\}}{[]}{[]} \]
Now, let $c_0 \triangleq \initstate(\module)$.
Then $\module$ is \emph{safe}, denoted by $\issafe(\module)$, if:
\[ \forall c. \ c_{0} \multistep c \implies \neg \errorstate(c) \]
(The relation $\multistep$ is the reflexive-transitive closure of the relation $\step$.)
\end{definition}

\begin{definition}
\label{def:well-formed}
A memory object $(\addr, \size, \arrayvalue)$ is well-formed if its interval does not wrap around the address space,
\ie $a + \zeroext_{\bvsort{64}}(s)$ does not overflow.
A memory $\memory$ is well-formed if all its memory objects are well-formed.
A concrete state $\progstate{\location}{\localstore}{\stack}{\memory}$ is well-formed if $\memory$ is well-formed.
\end{definition}


\subsection{SMT}
...
