\section{Background}

\subsection{LLVM Memory Model}

\begin{itemize}
    \item data layout
\end{itemize}

\subsection{Concrete Semantics}
\label{sec:concrete-semantics}

% TODO: ignore alignment details
% TODO: drop: allocas, globals
% TODO: we assume that the argument of malloc is a constant
% TODO: add type to malloc/free/gep?
% TODO: say that we assume: pointer type = i64 / index type = i32

A \emph{memory object} is defined as a tuple:
\[ (\addr, \size, \arrayvalue) \in \Vals^{\pointertype} \times \Vals^{\indextype} \times \Arrays \quad \quad \Arrays \triangleq \Z \rightarrow \Vals^{\bvsort{8}} \cup \{\tundef, \tpoison\} \]
A memory object has a base address $\addr$, a size $\size$, and mapping $\arrayvalue$ which tracks the stored values.
A stored value can be either a value of type $\Vals^{\bvsort{8}}$ (\ie a byte) or one of the special values $\tundef$ or $\tpoison$.
The memory is defined using a \emph{heap} and an \emph{allocator}.
A heap $\heap \in \Heaps$ is a set memory objects.
An allocator is an algorithm that defines the allocation scheme of memory objects.
Whenever an allocator adds a new memory object to the heap,
the address interval of that memory object must not overlap with the address intervals of existing memory objects.
In addition, an address interval must not wrap around the address space, \ie it must hold that:
\[ \addr \leq \addr + \size \]

% TODO: modeling a generic allocator is hard...
In this work, we assume a linear allocator that allocates memory objects in an ascending order while maintaining a constant gap (also known as \emph{red-zone}) between memory objects.

\subsubsection{Malloc}
% size check / UB

\subsubsection{Free}
% points-to check

\subsubsection{Load}

\subsubsection{Store}

\subsubsection{GetElementPtr}
% mention flags (nuw, nusw, inbounds)

\begin{figure}
\scalebox{0.9}{
$
\begin{array}{l@{~}r@{~{}~}l}
  \tbinop & ~::={} & \opcode{add} ~|~ \opcode{sub} ~|~ \opcode{mul} ~|~ \opcode{urem} ~|~ \sdots \\
  \tcmpop & ~::={} & \opcode{eq} ~|~ \opcode{ne} ~|~ \opcode{ugt} ~|~ \opcode{uge} ~|~ \opcode{ult} ~|~ \opcode{ule} ~|~ \sdots \\
  \toper & ~::={} & binop ~|~ \opcode{icmp}_{cmpop} \\
  \tcast & ~::={} & \opcode{zext} ~|~ \opcode{sext} ~|~ \opcode{trunc} ~|~ \opcode{bitcast} \\
  e & ~::={} & n ~|~ x ~|~ \toper^\tau~e_1~e_2 ~|~ \tcast^{\tau\to\tau'}~e \\
  \tinstr & ~::={} & x ~\texttt{=}~ e \ | \ x ~\texttt{=}~ \tphi^\tau~\{\,\overline{b_i\mapsto e_i}\,\} \ | \ \tbr~b \ | \ \tbr~e~b_1~b_2 \ | \\
          & & \tcall~\tid~(\overline{\tau_i~e_i}) \ | \ x ~\texttt{=}~ \tcall^{\tau}~\tid~(\overline{\tau_i~e_i}) \ | \ \tret \ | \ \tret^{\tau}~e \ | \ \tunreachable \ | \\
          & & x ~\texttt{=}~ \tload^{\tau}~e \ | \ \tstore^{\tau}~e_1~e_2 \ | \ \tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)} \\
  \tblk & ~::={} & \tid{:}~\overline{\tinstr} \\
  \tfunc & ~::={} & \tdef~\tau~\tid(\overline{\tau_i~x_i})
                   ~ \{~\overline{\tblk}~\} \\
  \tmodule & ~::={} & \overline{\tfunc}
\end{array}
$
}
\caption{A simplified syntax of \llvm IR.}
\label{figure:llvm-syntax}
\end{figure}

\begin{figure}
\[
\begin{array}{cl}
\ruledefsmall{Assign}{
  \instrat{\location} = \codequote{v~\texttt{=}~e} \quad
  e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
  \welldef{\evalexprty{e}\sigma\tau \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto \evalexprty{e}\sigma\tau]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Branch-True}{
  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1 \quad
  \welldef{\location\triangleright b_i \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\location\triangleright b_1}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Branch-True}{
  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{0}1 \quad
  \welldef{\location\triangleright b_i \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \progstate{\location}{\localstore}{\stack}
  \step
  \progstate{\location\triangleright b_2}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Make-Symbolic}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{32}}~\intrinsicfunc{make\_symbolic}()}
  \quad n \in \Z
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto n@\bvsort{32}]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Assume}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{assume}(e)} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Malloc}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\pointertype}~\intrinsicfunc{malloc}(e)} \quad
  \evalexprty{e}{\localstore}{\indextype} = n \quad
  \mathit{allocate}(\memory, n) = (\memory', p) \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto p]}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Free}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{free}(e)} \quad
  \evalexprty{e}{\localstore}{\pointertype} = p \quad
  \mathit{mo} \in \memory \quad
  \mathit{is\_base\_address}(p, mo) \quad
  \mathit{remove}(\memory, \mathit{mo}) = \memory'
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Load}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\localstore}{\pointertype} = p \quad
  \mathit{mo} \in \memory \quad
  \mathit{is\_inbounds}(p, |\tau|, mo) \quad
  \mathit{read}(\mathit{mo}, p, \tau) = v \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto v]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Store}{
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\localstore}{\tau} = v \quad
  \evalexprty{e_2}{\localstore}{\pointertype} = p \quad
  \mathit{mo} \in \memory \quad
  \mathit{is\_inbounds}(p, |\tau|, mo) \quad
  \mathit{write}(\mathit{mo}, p, v) = \mathit{mo}' \quad
  \mathit{replace}(\memory, \mathit{mo}') = \memory'
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{GetElementPtr}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}} \quad
  |\overline{(\tau_i, e_i)}| > 0 \quad
  \evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p \quad
  \evalexprty{e_i}{\localstore}{\tau_i} = j_i \quad
  \mathit{eval\_gep}(\tau, p, j_0, [...]) = v
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto v]}{\stack}{\memory}
}
\end{array}
\]
\caption{Operational small-step semantics of \llvm IR.}
\label{figure:llvm-semantics}
\end{figure}

\begin{algorithm}[t]
\caption{The basic semantics of \tgep.}
\label{alg:gep-klee}
\begin{algorithmic}[1]

\Function{compute-offset}{$\tau, o, \overline{j}$}
    \If {$|\overline{j}| = 0$}
        \State \Return $o$
    \EndIf
    \State $\overline{j} \gets j_1 :: \overline{j'}$
    \If {$\tau = \arraytype{\tau'}$}
        \State $o \gets o + \mathit{sign\_ext}_{\indextype}(j_1) \cdot |\tau'|$
        \State \Return \Call{compute-offset}{$\tau', o, \overline{j'}$}
    \EndIf
    \If {$\tau = \structtype{\overline{\tau}}$}
        \State $n \gets \mathit{to\_nat}(j_1)$
        \State $\tau_{n} \gets \mathit{field\_type}(\overline{\tau}, n)$
        \State $o \gets o + \mathit{field\_offset}(\overline{\tau}, n)$
        \State \Return \Call{compute-offset}{$\tau_{n}, o, \overline{j'}$}
    \EndIf
    \State ...
\EndFunction

\Function{compute-pointer}{$\tau, p, j_0, \overline{j}$}
    \State $o \gets \mathit{trunc}_{\indextype}(j_0) \cdot |\tau|$
    \State $r \gets \Call{compute-offset}{\tau, o, \overline{j}}$
    \State \Return $p + \mathit{zero\_ext}_{\pointertype}(r)$
\EndFunction

\Function{eval-gep}{$\tau, p, j_0, \overline{j}$}
    \If {$\tpoison \in \{j_0\} \cup \overline{j}$}
        \State \Return $\tpoison$
    \EndIf
    \If {$\tundef \in \{j_0\} \cup \overline{j}$}
        \State \Return $\tundef$
    \EndIf
    \State \Return \Call{compute-pointer}{$\tau, p, j_0, \overline{j}$}
\EndFunction

\end{algorithmic}
\end{algorithm}

% TODO: a quick overview of basic instructions
% TODO: semantics of memory-related instructions
% TODO: memory allocator?
