\section{Basic Foundations and Definitions}
\label{sec:background}

% TODO: explain bit-vectors

In this section,
we provide background on \llvm IR~\cite{llvm} and on satisfiability modulo theories (SMT).

\subsection{LLVM}

\llvm IR is a low-level intermediate representation for languages such as C, C++, and Rust.
Beyond its role in compilation,
\llvm IR is widely used in program analysis (symbolic execution, model checking, static analysis, \etc).
In the following,
we describe the aspects of \llvm IR that are relevant for our development.
% TODO: The semantics presented here are largely based on~\cite{klee-rocq}, and we further extend them to memory operations.

\subsubsection{\textit{Syntax.}}

\begin{figure}
\scalebox{0.9}{
$
\begin{array}{l@{~}r@{~{}~}l}
\tau & ~::={} & \bvsort{$w$} \ | \ \pointertypeof{\tau} \ | \ \arraytype{\tau}{n} \ | \ \structtype{\tau}{n} \\
\tbinop & ~::={} & \opcode{add} ~|~ \opcode{sub} ~|~ \opcode{mul} ~|~ \opcode{urem} ~|~ \sdots \\
\tcmpop & ~::={} & \opcode{eq} ~|~ \opcode{ne} ~|~ \opcode{ugt} ~|~ \opcode{uge} ~|~ \opcode{ult} ~|~ \opcode{ule} ~|~ \sdots \\
\toper & ~::={} & binop ~|~ \opcode{icmp}_{cmpop} \\
\tcast & ~::={} & \opcode{zext} ~|~ \opcode{sext} ~|~ \opcode{trunc} ~|~ \opcode{bitcast} \\
e & ~::={} & n ~|~ x ~|~ \toper^\tau~e_1~e_2 ~|~ \tcast^{\tau\to\tau'}~e \\
\tinstr & ~::={} & x ~\texttt{=}~ e \ | \ x ~\texttt{=}~ \tphi^\tau~\{\,\overline{b_i\mapsto e_i}\,\} \ | \ \tbr~b \ | \ \tbr~e~b_1~b_2 \ | \\
        & & \tcall~\tid~(\overline{\tau_i~e_i}) \ | \ x ~\texttt{=}~ \tcall^{\tau}~\tid~(\overline{\tau_i~e_i}) \ | \ \tret \ | \ \tret^{\tau}~e \ | \ \tunreachable \ | \\
        & & x ~\texttt{=}~ \tload^{\tau}~e \ | \ \tstore^{\tau}~e_1~e_2 \ | \ \tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)} \\
\tblk & ~::={} & \tid{:}~\overline{\tinstr} \\
\tfunc & ~::={} & \tdef~\tau~\tid(\overline{\tau_i~x_i})
                 ~ \{~\overline{\tblk}~\} \\
\tmodule & ~::={} & \overline{\tfunc}
\end{array}
$
}
\caption{A simplified syntax of \llvm IR.}
\label{figure:llvm-syntax}
\end{figure}

In this paper,
we focus on a subset of \llvm IR with memory operations, whose syntax is given in~\Cref{figure:llvm-syntax}.
Integers are represented as bit-vectors of type $\bvsort{w}$, where \textsf{w} denotes the bit width.
Array types are parametrized by an element type $\tau$ and a dimension $n$,
while struct types are parametrized by a sequence of field types.
We define $\Vals^{\bvsort{w}}$ as the set of all bit-vectors of type $\bvsort{w}$,
including the special values $\tundef$ and $\tpoison$, which are defined in the \llvm reference.
We use the notation $\bvval{n}{w}$ to denote a bit-vector of type $\bvsort{$w$}$ whose (signed or unsigned) numerical value is $n$.

\subsubsection{\textit{LLVM Memory Model.}}

% TODO: mention address space
According to the \llvm reference, a \emph{data layout} specifies how data is to be laid out in memory.
%The data layout consists of a list of specifications,
%including endianness, alignment rules, \etc
In particular, it defines various properties related to pointers, such as \emph{pointer type} and \emph{index type}.
The pointer type specifies the integral type used to represent pointer values.
The index type specifies the type used for address calculations (\eg in \tgep).
The size of the index type may not exceed the size of the pointer type.
An allocated object is a region of the address space reserved by a memory-allocation operation,
such as \textsf{alloca}, a heap allocation call (\eg \textit{malloc}), or a global variable definition.
An allocated object may not cross the unsigned boundary of the address space,
and its size may not exceed the largest signed integer representable by the index type.
% In addition, the index type also specifies the type used to represent the size of allocated objects.
In the sequel,
the bit-widths of the pointer type and the index type are denoted by \textsf{ptr} and \textsf{idx}, respectively, with corresponding integral types
\textsf{iptr} and \textsf{iidx}.

\subsubsection{\textit{Concrete Semantics.}}
\label{sec:concrete-semantics}

\begin{figure}
\[
\begin{array}{cl}
%\ruledefsmall{Assign}{
%  \instrat{\location} = \codequote{v~\texttt{=}~e} \quad
%  e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
%  \welldef{\evalexprty{e}\localstore\tau \neq \bot}
%}
%{
%  \progstate{\location}{\localstore}{\stack}{\memory}
%  \step
%  \progstate{\nextinstr{\location}}{\localstore[x \mapsto \evalexprty{e}\localstore\tau]}{\stack}{\memory}
%}
%\\[1em]
%\ruledefsmall{Branch-True}{
%  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
%  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1 \quad
%  \welldef{\location\triangleright b_i \neq \bot}
%}
%{
%  \progstate{\location}{\localstore}{\stack}{\memory}
%  \step
%  \progstate{\location\triangleright b_1}{\localstore}{\stack}{\memory}
%}
%\\[1em]
%\ruledefsmall{Branch-True}{
%  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
%  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{0}1 \quad
%  \welldef{\location\triangleright b_i \neq \bot}
%}
%{
%  \progstate{\location}{\localstore}{\stack}{\memory}
%  \step
%  \progstate{\location\triangleright b_2}{\localstore}{\stack}{\memory}
%}
%\\[1em]
%\ruledefsmall{Make-Symbolic}{
%  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\bvsort{32}}~\intrinsicfunc{make\_symbolic}()}
%  \quad n \in \Z
%}
%{
%  \progstate{\location}{\localstore}{\stack}{\memory}
%  \step
%  \progstate{\nextinstr{\location}}{\localstore[x \mapsto n@\bvsort{32}]}{\stack}{\memory}
%}
%\\[1em]
%\ruledefsmall{Assume}{
%  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{assume}(\bvsort{1} ~ e)} \quad
%  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1
%}
%{
%  \progstate{\location}{\localstore}{\stack}{\memory}
%  \step
%  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory}
%}
%\\[1em]
\ruledefsmall{Malloc}{\quad
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall^{\pointertypeof{\bvsort{8}}}~\intrinsicfunc{malloc}(\bvsort{64} ~ e)} \quad
  \evalexprty{e}{\localstore}{\bvsort{64}} = \bvval{n}{64} \quad
  \allocate(\memory, \valoftype{n}{\indextype}) = (\memory', p) \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto p]}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Free}{\quad
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{free}(\pointertypeof{\bvsort{8}} ~ e)} \quad
  \evalexprty{e}{\localstore}{\pointertypeof{\bvsort{8}}} = p \quad
  \mo \in \memory \quad
  \isbaseaddr{p}{\mo} \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}
    {\memory \setminus \{\mo\}}
}
\\[1em]
\ruledefsmall{Load}{\quad
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p \quad
  \mo \in \memory \quad
  \isinbounds{p}{\tau}{\mo} \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}
    {\localstore[x \mapsto \moRead{\mo}{p}{\tau}]}
    {\stack}{\memory}
}
\\[1em]
\ruledefsmall{Store}{\quad
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\localstore}{\tau} = v \quad
  \evalexprty{e_2}{\localstore}{\pointertypeof{\tau}} = p \quad
  \mo \in \memory \quad
  \isinbounds{p}{\tau}{\mo} \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\heapWrite{\memory}{\mo}{p}{v}}
}
\\[1em]
\ruledefsmall{GEP}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tgep~\pointertypeof{\tau}~e~\overline{(\tau_i, e_i)}} \quad
  |\overline{(\tau_i, e_i)}| > 0 \quad
  \evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p \quad
  \evalexprty{e_i}{\localstore}{\tau_i} = j_i
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}
    {\localstore[x \mapsto \evalgep(\tau, p, \overline{j_i})]}
    {\stack}{\memory}
}
\\[2em]
\scalebox{0.9}{$
\begin{array}{l@{\quad}l}

\nextinstr{\location} & \mbox{next program location} \\
\isinbounds{p}{\tau}{\mo} & \mbox{interval $[p,p+\sizeof{\tau})$ is contained within the address interval of $\mo$} \\
\moRead{\mo}{p}{\tau}   & \mbox{read a value of type $\tau$ from memory object $\mo$ starting from address $p$} \\
\moWrite{\mo}{p}{v} & \mbox{write value $v$ into memory object $\mo$ at address $p$} \\
\heapReplace{\memory}{\mo}{\mo'} & \mbox{update $\memory$ by replacing memory object $\mo$ with $mo'$}
\end{array}
$}
\end{array}
\]
\caption{Operational small-step semantics of \llvm IR.}
\label{figure:llvm-semantics}
\end{figure}

% TODO: ignore alignment details
% TODO: say that we assume: pointer type = i64 / index type = i32
% TODO: say the LLVM allows some freedom in the repr of memory objects / address spaces / etc.
% TODO: UB is interpreted as an error

%The most common depiction of program memory (a.k.a.\@ the ``flat model'') is a single,
%large block of memory bytes, with addresses being simple byte indexes.
The \llvm reference leaves some aspects of the memory model unspecified,
such as the representation of allocated objects and address spaces.
This flexibility allows different semantic interpretations,
and in this work,
we adopt the \emph{memory-object model}~\cite{klee,mossberg2019manticore} which is widely used in \SE tools.

\begin{definition}
\label{def:memory}
A memory object is defined as a tuple:
\[ \mobj{\addr}{\size}{\arrayvalue} \in \MemoryObjects \quad \quad \MemoryObjects \triangleq \Vals^{\pointertype} \times \Vals^{\indextype} \times (\Z \rightarrow \Vals^{\bvsort{8}} \cup \{\tundef, \tpoison\}) \]
where $\addr$ is its base address, $\size$ is its size, and $\arrayvalue$ is a mapping that tracks the stored values.
A stored value can be either a value of type $\Vals^{\bvsort{8}}$ (\ie a byte) or one of the special values $\tundef$ or $\tpoison$.
%The address space is defined by the unsigned range representable by the pointer index type.
%Each memory object is associated with an address interval, $[\addr, \addr + \size)$.
A heap is defined as a set of memory objects.
We use $(\MemoryObjects)^*$ to refer to the set of possible heaps.
\end{definition}

We assume an implicit \emph{allocator},
which is a stateful function $(\MemoryObjects)^* \to \MemoryObjects$,
providing a freshly-allocated memory object whose address interval must not overlap those of existing memory objects.
Moreover, the address interval must be fully contained within the address space, \ie $\addr + \size$ must not overflow.

In this paper,
we assume a linear allocator that allocates memory objects consecutively, while maintaining a fixed gap between,
commonly referred to as a \emph{red-zone}.
Modeling a generic allocator that allows arbitrary locations for memory objects would be far more challenging.
First, modeling such allocators requires developing a more complex theory of memory (\Cref{sec:core}).
Second, existing \SE tools do not support such allocators,
so generating safety proofs using these tools would require significant modifications to their implementations (\Cref{sec:proof-generation}).
Therefore, we leave the modeling of such allocators to future work.

\begin{definition}\label{def:state}
%A location $\location\in\Locs$ is specified by a function identifier, block identifier, instruction index,
%and an optional previous-block identifier.
A \emph{concrete state} is a tuple $\progstate{\location}{\localstore}{\stack}{\memory}$,
where $\location \in \Locs$ is a program location,
$\localstore \in \Stores$ is a \emph{local store} that maps variables to values in $\Vals$,
$\stack \in (\Locs \times \Stores \times \Ids)^{*}$ is a call stack represented as a sequence of frames,
and $\memory \in (\MemoryObjects)^{*}$ is a sequence of memory objects.
\end{definition}

\Cref{figure:llvm-semantics} defines the operational small-step semantics of \llvm IR based on the syntax in~\Cref{figure:llvm-syntax}.
The evaluation semantics of an expression $e$ in a context of a local store $\localstore \in \Stores$ when a value of type $\tau$ is expected,
denoted as $\evalexprty{e}{\localstore}{\tau}$,
is defined according to~\cite{klee-rocq} (Section 2.1.2).
%The rules \rulenameref{Assign}, \rulenameref{Branch-True}, \rulenameref{Branch-False}, \rulenameref{Make-Symbolic}, and \rulenameref{Assume}
%were discussed in detail in~\cite{klee-rocq},
Here, we focus on discussing the memory-related instructions,
as the rules for other instructions (assignments, branches, \etc) were already discussed in detail in~\cite{klee-rocq}.


\subsubsection{\textit{Malloc.}}
When allocating a memory object,
the size of the allocation must be non-negative and must not exceed the largest signed integer representable by the index type.\footnote{
The semantics presented in the paper consider only heap allocations.
However, our implementation supports stack and global allocations as well.
}
As mentioned before, the address interval of the allocated memory object may not cross the unsigned boundary of the address space.
If one of these properties is violated, the result is undefined behavior.
The mapping of the newly allocated memory object is set to a function that maps all the indices to $\bvval{0}{8}$.

\subsubsection{\textit{Free.}}
% TODO: assume that the type of p is iptr?
When deallocating a pointer value $p$,
we first check if there exists a memory object $\mobj{\addr}{\size}{\arrayvalue}$ in the memory $\memory$ such that $p = \addr$.
If that is the case, we remove that memory object from $\memory$.
Otherwise, the result is undefined behavior.

\subsubsection{\textit{Load.}}
% TODO: what happens if p is undef/poison?
When reading $n$ bytes from a pointer value $p$,
we need to make sure that there exists a memory object $\mobj{\addr}{\size}{\arrayvalue}$ in the memory $\memory$ such that
(1) $p < p + n$ (\ie there is no overflow) and (2) $\addr \leq p < \addr + \size$.
If that is not the case, then the result is undefined behavior.
Otherwise, we use the \textit{read} procedure to obtain the accessed value.
This procedure first reads the corresponding sequence of stored values.
If one of these values is $\tpoison$, then it returns $\tpoison$.
If one of these values is $\tundef$, then it returns $\tundef$.
Otherwise, we deserialize this sequence of values (bytes) into an integer of the appropriate type.

\subsubsection{\textit{Store.}}
% TODO: what happens if p/v is undef/poison?
When writing a value $v$ to a pointer value $p$,
we need to make sure that there exists a memory object $\mobj{\addr}{\size}{\arrayvalue}$ in the memory $\memory$ such that
(1) $p < p + n$ and (2) $\addr \leq p < \addr + \size$.
If that is not the case, then the result is undefined behavior.
Otherwise, we use the \textit{write} procedure to store the value $v$.
This procedure serializes the value $v$ into a sequence of bytes and updates the array $\arrayvalue$ accordingly.

\subsubsection{\textit{GetElementPtr.}}

The $\tgep$ instruction computes the address of a subelement of an aggregate data structure (array, struct, \etc.).\footnote{
\Cref{appendix:concrete-semantics} provides the pseudo-code of the semantics, defined as the function $\evalgep$.
}
The first argument is the base pointer to start from,
and the remaining arguments are indices that indicate which of the elements of the aggregate object are indexed.
All the indices are first converted to values of the index type (sign-extended or truncated), and then translated into offsets.
The first index is used to move accross the elements corresponding to the base pointer type,
so it is multiplied by the type size of the element type of the base pointer type.
The remaining indices are translated into offsets based on the indexed type.
If the indexed type is an array type,
then the index is multiplied by the type size of the indexed type.
If the indexed type is a struct type,
then the index is translated into a field selector.
The computed offsets are sequentially summed up,
and then the resulting offset is converted to the pointer type and added to the base pointer.

The $\tgep$ instruction may have attributes (\opcode{nuw}, \opcode{nusw}, and \opcode{inbounds}) that impose additional rules.
For example, when the \opcode{nuw} attribute is enabled, the following conditions must hold:
(1) if the type of an index is larger than the index type, the truncation to the index type must preserve the unsigned value,
(2) the multiplication of an index by the type size does not cause an unsigned overflow of the index type, and
(3) the successive addition of each offset does not cause an unsigned overflow of the index type.
If any of these conditions is violated, the result is $\tpoison$.

In the following,
we define when a concrete state is considered to be an error state.
We then define when a program, \ie an \llvm module, is considered safe.

% TODO: some text before?
\begin{definition}
\label{def:error-state}
Let $c \triangleq \progstate{\location}{\localstore}{\stack}{\memory}$ be a concrete state.
Then $c$ is an error state, denoted by $\errorstate(c)$, if one of the following holds:
\begin{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{\tunreachable}$}$
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ op \ \bvsort{w} \ e_1 \ e_2}$}$, and one of the following holds, where $v_k \triangleq \evalexprty{e_k}{\localstore}{\bvsort{w}}$:
    \begin{enumerate}[left=-3pt]
        \item \textup{$op \in \{\opcode{udiv}, \opcode{sdiv}, \opcode{urem}, \opcode{srem}\}$ and $v_2 = \bvval{0}{w}$}
        \item \textup{$op = \opcode{sdiv}$, $v_1 = \bvval{(-2^{w - 1})}{w}$, and $v_2 = \bvval{(-1)}{w}$}
        \item \textup{$op \in \{\opcode{shl}, \opcode{lshr}, \opcode{ashr}\}$ and $v_2 = \bvval{n}{w}$, and $n \geq w$}
    \end{enumerate}
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tcall^{\pointertypeof{\bvsort{8}}} \ \intrinsicfunc{malloc}(\bvsort{64} \ e)}$}$,
          and \textup{$\evalexprty{e}{\localstore}{\bvsort{64}} > \bvval{(2^{\indexwidth - 1} - 1)}{64}$}.
    \item $\instrat{\location} = \textup{$\codequote{\tcall~\intrinsicfunc{free}(\pointertypeof{\bvsort{8}} \ e)}$}$, \textup{$\evalexprty{e}{\localstore}{\pointertypeof{\bvsort{8}}} = p$},
          and there is no $\mo \in \memory$ s.t. $\isbaseaddr{p}{\mo}$.
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tload^{\tau} \ e}$}$, \textup{$\evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p$},
          and there is no $\mo \in \memory$ s.t. $\isinbounds{p}{|\tau|}{\mo}$.
    \item $\instrat{\location} = \textup{$\codequote{\tstore^{\tau} \ e_1 \ e_2}$}$, \textup{$\evalexprty{e_2}{\localstore}{\pointertypeof{\tau}} = p$},
          and there is no $\mo \in \memory$ s.t. $\isinbounds{p}{|\tau|}{\mo}$.
    % TODO: $|\overline{(\tau_i, e_i)}| > 0$
    \item $\instrat{\location} = \textup{$\codequote{x \ \texttt{=} \ \tgep~\pointertypeof{\tau} \ e \ \overline{(\tau_i, e_i)}}$}$, and:
    \begin{enumerate}
        \item \textup{$\evalexprty{e}{\localstore}{\pointertypeof{\tau}} = p$}, $\evalexprty{e_i}{\localstore}{\tau_i} = j_i$, and $\evalgep(\tau, p, \overline{j_i}) = \tpoison$.
    \end{enumerate}
\end{enumerate}
\end{definition}

\begin{definition}
\label{def:safety}
Let $f$ be the entry function in the module $\module$.
The \emph{initial state} is defined as:
\[ \initstate(\module) \triangleq \progstate{f\hspace{-2pt}.\funcentry}{\{\}}{[]}{[]} \]
Now, let $c_0 \triangleq \initstate(\module)$.
Then $\module$ is \emph{safe}, denoted by $\issafe(\module)$, if:
\[ \forall c. \ c_{0} \multistep c \implies \neg \errorstate(c) \]
(The relation $\multistep$ is the reflexive-transitive closure of the relation $\step$.)
\end{definition}

% TODO: needed only internally
%\begin{definition}
%\label{def:well-formed}
%A memory object $(\addr, \size, \arrayvalue)$ is well-formed if its interval does not wrap around the address space,
%\ie $a + \zeroext_{\bvsort{64}}(s)$ does not overflow.
%A memory $\memory$ is well-formed if all the memory objects are well-formed and there are no memory objects with overlapping address intervals.
%A concrete state $\progstate{\location}{\localstore}{\stack}{\memory}$ is well-formed if $\memory$ is well-formed.
%\end{definition}

\subsection{SMT}
We focus on first-order logic modulo the theory of bit-vectors and arrays (QFABV),
which is widely used in symbolic execution tools.
The bit-vector theory defines the $\mathsf{BV}[w]$ sort, which is interpreted as the set $\{0{,}1\}^w$,
and it defines \emph{interpreted} function symbols for operations over values of bit-vector sorts (\eg $\textit{bvadd}$).
The array theory defines the array sort $\arraysort{I}{V}$ parametrized by an index sort $I$ and a value sort $V$,
which is interpreted as a total map of the appropriate type.\footnote{
In our context, we assume that both $I$ and $V$ are bit-vector sorts.
}
It defines the interpreted function symbols \textit{select}, \textit{store}, and \textit{K}.
Semantically,
$\mathit{select}(a, i)$ returns the value stored at index $i$ in $a$,
$\mathit{store}(a, i, v)$ return the array obtained from $a$ by updating the value at index $i$ to $v$,
and $K(v)$ returns a constant array that maps all the indices to $v$.
A \emph{model} $m$ must map interpreted function symbols to their accepted functions over $\{0{,}1\}^w$.
As is typically done in the context of symbolic execution,
we identify the $\Bool$ sort with $\mathsf{BV}[1]$,
such that $\true$ and $\false$ correspond to $1$ and $0$, respectively.

\begin{paragraph}{\textbf{Notations.}}
We denote by $m[t]$ the interpretation of the term $t$ in a model $m$.
We denote by $t_1\equiv t_2$ the assertion that $m[t_1] = m[t_2]$ for any model $m$.
We use $\arrayselect{a}{i}$ and $\arraystore{a}{i}{v}$ as shorthands for $\mathit{select}(a, i)$ and $\mathit{store}(a, i, v)$.
\end{paragraph}
