\section{Background}

\subsection{LLVM Memory Model}

\begin{itemize}
    \item data layout
\end{itemize}

\subsection{Concrete Semantics}
\label{sec:concrete-semantics}

% TODO: ignore alignment details
% TODO: drop: allocas, globals
% TODO: we assume that the argument of malloc is a constant
% TODO: add type to malloc/free/gep?

\begin{figure}
\scalebox{0.9}{
$
\begin{array}{l@{~}r@{~{}~}l}
  \tbinop & ~::={} & \opcode{add} ~|~ \opcode{sub} ~|~ \opcode{mul} ~|~ \opcode{urem} ~|~ \sdots \\
  \tcmpop & ~::={} & \opcode{eq} ~|~ \opcode{ne} ~|~ \opcode{ugt} ~|~ \opcode{uge} ~|~ \opcode{ult} ~|~ \opcode{ule} ~|~ \sdots \\
  \toper & ~::={} & binop ~|~ \opcode{icmp}_{cmpop} \\
  \tcast & ~::={} & \opcode{zext} ~|~ \opcode{sext} ~|~ \opcode{trunc} ~|~ \opcode{bitcast} \\
  e & ~::={} & n ~|~ x ~|~ \toper^\tau~e_1~e_2 ~|~ \tcast^{\tau\to\tau'}~e \\
  \tinstr & ~::={} & x ~\texttt{=}~ e \ | \ x ~\texttt{=}~ \tphi^\tau~\{\,\overline{b_i\mapsto e_i}\,\} \ | \ \tbr~b \ | \ \tbr~e~b_1~b_2 \ | \\
          & & \tcall^{\tau}~\tid~(\overline{\tau_i~e_i}) \ | \ x ~\texttt{=}~ \tcall^{\tau}~\tid~(\overline{\tau_i~e_i}) \ | \ \tret^{\tau}~e \ | \ \tunreachable \ | \\
          & & x ~\texttt{=}~ \tload^{\tau}~e \ | \ \tstore^{\tau}~e_1~e_2 \ | \ \tgep~e~\overline{(\tau_i, e_i)} \\
  \tblk & ~::={} & \tid{:}~\overline{\tinstr} \\
  \tfunc & ~::={} & \tdef~\tau~\tid(\overline{\tau_i~x_i})
                   ~ \{~\overline{\tblk}~\} \\
  \tmodule & ~::={} & \overline{\tfunc}
\end{array}
$
}
\caption{A simplified syntax of \llvm IR.}
\label{figure:llvm-syntax}
\end{figure}

\begin{figure}
\[
\begin{array}{cl}
\ruledefsmall{Assign}{
  \instrat{\location} = \codequote{v~\texttt{=}~e} \quad
  e = \codequote{\toper^\tau\sdots} / \codequote{\tcast^{\_ \to \tau}\sdots} \quad
  \welldef{\evalexprty{e}\sigma\tau \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto \evalexprty{e}\sigma\tau]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Branch-True}{
  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1 \quad
  \welldef{\location\triangleright b_i \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\location\triangleright b_1}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Branch-True}{
  \instrat{\location} = \codequote{\tbr~e~b_1~b_2} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{0}1 \quad
  \welldef{\location\triangleright b_i \neq \bot}
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \progstate{\location}{\localstore}{\stack}
  \step
  \progstate{\location\triangleright b_2}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Make-Symbolic}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall~\intrinsicfunc{make\_symbolic}()}
  \quad n\in\Nat
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto n@\bvsort{32}]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Assume}{
  \instrat{\location} = \codequote{\tcall~\intrinsicfunc{assume}(e)} \quad
  \evalexprty{e}{\localstore}{\bvsort{1}} = \bvval{1}1
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Malloc}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tcall~\tmalloc(e)} \quad
  \evalexprty{e}{\localstore}{\bvsort{32}} = n \quad
  \mathit{allocate}(\memory, n) = (\memory', p) \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto p]}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Free}{
  \instrat{\location} = \codequote{\tcall~\tfree(e)} \quad
  \evalexprty{e}{\localstore}{\bvsort{64}} = p \quad
  \mathit{mo} \in \memory \quad
  \mathit{is\_base\_address}(p, mo) \quad
  \mathit{remove}(\memory, \mathit{mo}) = \memory'
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory'}
}
\\[1em]
\ruledefsmall{Load}{
  \instrat{\location} = \codequote{x~\texttt{=}~\tload^{\tau}~e} \quad
  \evalexprty{e}{\localstore}{\bvsort{64}} = p \quad
  \mathit{mo} \in \memory \quad
  \mathit{is\_inbounds}(p, |\tau|, mo) \quad
  \mathit{read}(\mathit{mo}, p, \tau) = v \quad
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore[x \mapsto v]}{\stack}{\memory}
}
\\[1em]
\ruledefsmall{Store}{
  \instrat{\location} = \codequote{\tstore^{\tau}~e_1~e_2} \quad
  \evalexprty{e_1}{\localstore}{\tau} = v \quad
  \evalexprty{e_2}{\localstore}{\bvsort{64}} = p \quad
  \mathit{mo} \in \memory \quad
  \mathit{is\_inbounds}(p, |\tau|, mo) \quad
  \mathit{write}(\mathit{mo}, p, v) = \mathit{mo}' \quad
  \mathit{replace}(\memory, \mathit{mo}') = \memory'
}
{
  \progstate{\location}{\localstore}{\stack}{\memory}
  \step
  \progstate{\nextinstr{\location}}{\localstore}{\stack}{\memory'}
}
\end{array}
\]
\caption{Operational small-step semantics of \llvm IR.}
\label{figure:llvm-semantics}
\end{figure}

\begin{itemize}
    \item a quick overview of basic instructions
    \item semantics of memory-related instructions
    \item memory allocator?
\end{itemize}
